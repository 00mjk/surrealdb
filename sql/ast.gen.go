// +build go1.6

// Code generated by codecgen - DO NOT EDIT.

package sql

import (
	"errors"
	codec1978 "github.com/ugorji/go/codec"
	pkg1_language "golang.org/x/text/language"
	"runtime"
	"strconv"
	"time"
)

const (
	// ----- content types ----
	codecSelferCcUTF87834 = 1
	codecSelferCcRAW7834  = 255
	// ----- value types used ----
	codecSelferValueTypeArray7834     = 10
	codecSelferValueTypeMap7834       = 9
	codecSelferValueTypeString7834    = 6
	codecSelferValueTypeInt7834       = 2
	codecSelferValueTypeUint7834      = 3
	codecSelferValueTypeFloat7834     = 4
	codecSelferValueTypeNil7834       = 1
	codecSelferBitsize7834            = uint8(32 << (^uint(0) >> 63))
	codecSelferDecContainerLenNil7834 = -2147483648
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct7834 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer7834 struct{}

func codecSelfer7834False() bool { return false }

func init() {
	if codec1978.GenVersion != 16 {
		_, file, _, _ := runtime.Caller(0)
		ver := strconv.FormatInt(int64(codec1978.GenVersion), 10)
		panic("codecgen version mismatch: current: 16, need " + ver + ". Re-generate file: " + file)
	}
	if false { // reference the types, but skip this branch at build/run time
		var _ pkg1_language.Tag
		var _ time.Duration
	}
}

func (x *Query) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			x.Statements.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Statements\"")
			} else {
				r.EncodeString(`Statements`)
			}
			z.EncWriteMapElemValue()
			x.Statements.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Query) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Query{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Query) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Statements":
			x.Statements.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Query) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Statements.CodecDecodeSelf(d)
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Statements) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encStatements((Statements)(x), e)
	} // end block: if x slice == nil
}

func (x *Statements) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decStatements((*Statements)(x), d)
}

func (x *UseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.NS))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.DB))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NS\"")
			} else {
				r.EncodeString(`NS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.NS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DB\"")
			} else {
				r.EncodeString(`DB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.DB))
			z.EncWriteMapEnd()
		}
	}
}

func (x *UseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = UseStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *UseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "NS":
			x.NS = (string)(string(r.DecodeStringAsBytes()))
		case "DB":
			x.DB = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.NS = (string)(string(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DB = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *OptStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Name))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.What))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Name))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.What))
			z.EncWriteMapEnd()
		}
	}
}

func (x *OptStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = OptStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *OptStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			x.Name = (string)(string(r.DecodeStringAsBytes()))
		case "What":
			x.What = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *OptStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Name = (string)(string(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What = (bool)(r.DecodeBool())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *BeginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *BeginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = BeginStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *BeginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BeginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *CancelStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *CancelStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = CancelStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *CancelStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CancelStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *CommitStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *CommitStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = CommitStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *CommitStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CommitStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *InfoStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.EncExtension(x.Kind, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt7 := z.Extension(z.I2Rtid(x.Kind)); yyxt7 != nil {
				z.EncExtension(x.Kind, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *InfoStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = InfoStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *InfoStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.DecExtension(x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *InfoStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt9 := z.Extension(z.I2Rtid(x.Kind)); yyxt9 != nil {
		z.DecExtension(x.Kind, yyxt9)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *RunStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.Expr)); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(z.I2Rtid(x.Expr)); yyxt8 != nil {
				z.EncExtension(x.Expr, yyxt8)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RunStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RunStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RunStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Expr":
			if yyxt6 := z.Extension(z.I2Rtid(x.Expr)); yyxt6 != nil {
				z.DecExtension(x.Expr, yyxt6)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RunStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(z.I2Rtid(x.Expr)); yyxt10 != nil {
		z.DecExtension(x.Expr, yyxt10)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *LetStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.What)); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
			} else {
				z.EncFallback(x.What)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(z.I2Rtid(x.What)); yyxt11 != nil {
				z.EncExtension(x.What, yyxt11)
			} else {
				z.EncFallback(x.What)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *LetStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = LetStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *LetStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			if yyxt7 := z.Extension(z.I2Rtid(x.What)); yyxt7 != nil {
				z.DecExtension(x.What, yyxt7)
			} else {
				z.DecFallback(&x.What, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *LetStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(z.I2Rtid(x.What)); yyxt12 != nil {
		z.DecExtension(x.What, yyxt12)
	} else {
		z.DecFallback(&x.What, true)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *LiveStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(9)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.ID))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.FB))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.NS))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.DB))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Diff))
			z.EncWriteArrayElem()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt19 := z.Extension(z.I2Rtid(x.Cond)); yyxt19 != nil {
				z.EncExtension(x.Cond, yyxt19)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			x.Fetch.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(9)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ID\"")
			} else {
				r.EncodeString(`ID`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.ID))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"FB\"")
			} else {
				r.EncodeString(`FB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.FB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NS\"")
			} else {
				r.EncodeString(`NS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.NS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DB\"")
			} else {
				r.EncodeString(`DB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.DB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Diff\"")
			} else {
				r.EncodeString(`Diff`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Diff))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt28 := z.Extension(z.I2Rtid(x.Cond)); yyxt28 != nil {
				z.EncExtension(x.Cond, yyxt28)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Fetch\"")
			} else {
				r.EncodeString(`Fetch`)
			}
			z.EncWriteMapElemValue()
			x.Fetch.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *LiveStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = LiveStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *LiveStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "ID":
			x.ID = (string)(string(r.DecodeStringAsBytes()))
		case "FB":
			x.FB = (string)(string(r.DecodeStringAsBytes()))
		case "NS":
			x.NS = (string)(string(r.DecodeStringAsBytes()))
		case "DB":
			x.DB = (string)(string(r.DecodeStringAsBytes()))
		case "Diff":
			x.Diff = (bool)(r.DecodeBool())
		case "Expr":
			x.Expr.CodecDecodeSelf(d)
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Cond":
			if yyxt12 := z.Extension(z.I2Rtid(x.Cond)); yyxt12 != nil {
				z.DecExtension(x.Cond, yyxt12)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Fetch":
			x.Fetch.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *LiveStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.ID = (string)(string(r.DecodeStringAsBytes()))
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.FB = (string)(string(r.DecodeStringAsBytes()))
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.NS = (string)(string(r.DecodeStringAsBytes()))
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DB = (string)(string(r.DecodeStringAsBytes()))
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Diff = (bool)(r.DecodeBool())
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Expr.CodecDecodeSelf(d)
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt23 := z.Extension(z.I2Rtid(x.Cond)); yyxt23 != nil {
		z.DecExtension(x.Cond, yyxt23)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Fetch.CodecDecodeSelf(d)
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = z.DecCheckBreak()
		}
		if yyb14 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
}

func (x *KillStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.FB))
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"FB\"")
			} else {
				r.EncodeString(`FB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.FB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *KillStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = KillStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *KillStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "FB":
			x.FB = (string)(string(r.DecodeStringAsBytes()))
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *KillStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.FB = (string)(string(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *ReturnStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *ReturnStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = ReturnStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *ReturnStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ReturnStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *IfelseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			x.Cond.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.Then.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Else)); yyxt10 != nil {
				z.EncExtension(x.Else, yyxt10)
			} else {
				z.EncFallback(x.Else)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			x.Cond.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Then\"")
			} else {
				r.EncodeString(`Then`)
			}
			z.EncWriteMapElemValue()
			x.Then.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Else\"")
			} else {
				r.EncodeString(`Else`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(z.I2Rtid(x.Else)); yyxt14 != nil {
				z.EncExtension(x.Else, yyxt14)
			} else {
				z.EncFallback(x.Else)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *IfelseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = IfelseStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *IfelseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Cond":
			x.Cond.CodecDecodeSelf(d)
		case "Then":
			x.Then.CodecDecodeSelf(d)
		case "Else":
			if yyxt8 := z.Extension(z.I2Rtid(x.Else)); yyxt8 != nil {
				z.DecExtension(x.Else, yyxt8)
			} else {
				z.DecFallback(&x.Else, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *IfelseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Cond.CodecDecodeSelf(d)
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Then.CodecDecodeSelf(d)
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Else)); yyxt14 != nil {
		z.DecExtension(x.Else, yyxt14)
	} else {
		z.DecFallback(&x.Else, true)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x *SelectStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(13)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt19 := z.Extension(z.I2Rtid(x.Cond)); yyxt19 != nil {
				z.EncExtension(x.Cond, yyxt19)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			x.Split.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.Group.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.Order.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt23 := z.Extension(z.I2Rtid(x.Limit)); yyxt23 != nil {
				z.EncExtension(x.Limit, yyxt23)
			} else {
				z.EncFallback(x.Limit)
			}
			z.EncWriteArrayElem()
			if yyxt24 := z.Extension(z.I2Rtid(x.Start)); yyxt24 != nil {
				z.EncExtension(x.Start, yyxt24)
			} else {
				z.EncFallback(x.Start)
			}
			z.EncWriteArrayElem()
			x.Fetch.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt26 := z.Extension(z.I2Rtid(x.Version)); yyxt26 != nil {
				z.EncExtension(x.Version, yyxt26)
			} else {
				z.EncFallback(x.Version)
			}
			z.EncWriteArrayElem()
			if yyxt27 := z.Extension(z.I2Rtid(x.Timeout)); yyxt27 != nil {
				z.EncExtension(x.Timeout, yyxt27)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(13)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt32 := z.Extension(z.I2Rtid(x.Cond)); yyxt32 != nil {
				z.EncExtension(x.Cond, yyxt32)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Split\"")
			} else {
				r.EncodeString(`Split`)
			}
			z.EncWriteMapElemValue()
			x.Split.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Group\"")
			} else {
				r.EncodeString(`Group`)
			}
			z.EncWriteMapElemValue()
			x.Group.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Order\"")
			} else {
				r.EncodeString(`Order`)
			}
			z.EncWriteMapElemValue()
			x.Order.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Limit\"")
			} else {
				r.EncodeString(`Limit`)
			}
			z.EncWriteMapElemValue()
			if yyxt36 := z.Extension(z.I2Rtid(x.Limit)); yyxt36 != nil {
				z.EncExtension(x.Limit, yyxt36)
			} else {
				z.EncFallback(x.Limit)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Start\"")
			} else {
				r.EncodeString(`Start`)
			}
			z.EncWriteMapElemValue()
			if yyxt37 := z.Extension(z.I2Rtid(x.Start)); yyxt37 != nil {
				z.EncExtension(x.Start, yyxt37)
			} else {
				z.EncFallback(x.Start)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Fetch\"")
			} else {
				r.EncodeString(`Fetch`)
			}
			z.EncWriteMapElemValue()
			x.Fetch.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Version\"")
			} else {
				r.EncodeString(`Version`)
			}
			z.EncWriteMapElemValue()
			if yyxt39 := z.Extension(z.I2Rtid(x.Version)); yyxt39 != nil {
				z.EncExtension(x.Version, yyxt39)
			} else {
				z.EncFallback(x.Version)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt40 := z.Extension(z.I2Rtid(x.Timeout)); yyxt40 != nil {
				z.EncExtension(x.Timeout, yyxt40)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *SelectStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = SelectStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *SelectStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Expr":
			x.Expr.CodecDecodeSelf(d)
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Cond":
			if yyxt8 := z.Extension(z.I2Rtid(x.Cond)); yyxt8 != nil {
				z.DecExtension(x.Cond, yyxt8)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Split":
			x.Split.CodecDecodeSelf(d)
		case "Group":
			x.Group.CodecDecodeSelf(d)
		case "Order":
			x.Order.CodecDecodeSelf(d)
		case "Limit":
			if yyxt13 := z.Extension(z.I2Rtid(x.Limit)); yyxt13 != nil {
				z.DecExtension(x.Limit, yyxt13)
			} else {
				z.DecFallback(&x.Limit, true)
			}
		case "Start":
			if yyxt15 := z.Extension(z.I2Rtid(x.Start)); yyxt15 != nil {
				z.DecExtension(x.Start, yyxt15)
			} else {
				z.DecFallback(&x.Start, true)
			}
		case "Fetch":
			x.Fetch.CodecDecodeSelf(d)
		case "Version":
			if yyxt18 := z.Extension(z.I2Rtid(x.Version)); yyxt18 != nil {
				z.DecExtension(x.Version, yyxt18)
			} else {
				z.DecFallback(&x.Version, true)
			}
		case "Timeout":
			if yyxt20 := z.Extension(z.I2Rtid(x.Timeout)); yyxt20 != nil {
				z.DecExtension(x.Timeout, yyxt20)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SelectStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj22 int
	var yyb22 bool
	var yyhl22 bool = l >= 0
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Expr.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt27 := z.Extension(z.I2Rtid(x.Cond)); yyxt27 != nil {
		z.DecExtension(x.Cond, yyxt27)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Split.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Group.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Order.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt32 := z.Extension(z.I2Rtid(x.Limit)); yyxt32 != nil {
		z.DecExtension(x.Limit, yyxt32)
	} else {
		z.DecFallback(&x.Limit, true)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt34 := z.Extension(z.I2Rtid(x.Start)); yyxt34 != nil {
		z.DecExtension(x.Start, yyxt34)
	} else {
		z.DecFallback(&x.Start, true)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Fetch.CodecDecodeSelf(d)
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt37 := z.Extension(z.I2Rtid(x.Version)); yyxt37 != nil {
		z.DecExtension(x.Version, yyxt37)
	} else {
		z.DecFallback(&x.Version, true)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt39 := z.Extension(z.I2Rtid(x.Timeout)); yyxt39 != nil {
		z.DecExtension(x.Timeout, yyxt39)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj22++
		if yyhl22 {
			yyb22 = yyj22 > l
		} else {
			yyb22 = z.DecCheckBreak()
		}
		if yyb22 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj22-1, "")
	}
}

func (x *CreateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(z.I2Rtid(x.Data)); yyxt9 != nil {
				z.EncExtension(x.Data, yyxt9)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Echo)); yyxt10 != nil {
				z.EncExtension(x.Echo, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Timeout)); yyxt11 != nil {
				z.EncExtension(x.Timeout, yyxt11)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(z.I2Rtid(x.Data)); yyxt14 != nil {
				z.EncExtension(x.Data, yyxt14)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt15 := z.Extension(z.I2Rtid(x.Echo)); yyxt15 != nil {
				z.EncExtension(x.Echo, yyxt15)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(z.I2Rtid(x.Timeout)); yyxt16 != nil {
				z.EncExtension(x.Timeout, yyxt16)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *CreateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = CreateStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *CreateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Data":
			if yyxt6 := z.Extension(z.I2Rtid(x.Data)); yyxt6 != nil {
				z.DecExtension(x.Data, yyxt6)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Echo":
			if yyxt8 := z.Extension(z.I2Rtid(x.Echo)); yyxt8 != nil {
				z.DecExtension(x.Echo, yyxt8)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt10 := z.Extension(z.I2Rtid(x.Timeout)); yyxt10 != nil {
				z.DecExtension(x.Timeout, yyxt10)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CreateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt15 := z.Extension(z.I2Rtid(x.Data)); yyxt15 != nil {
		z.DecExtension(x.Data, yyxt15)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(z.I2Rtid(x.Echo)); yyxt17 != nil {
		z.DecExtension(x.Echo, yyxt17)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Timeout)); yyxt19 != nil {
		z.DecExtension(x.Timeout, yyxt19)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *UpdateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(6)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Data)); yyxt10 != nil {
				z.EncExtension(x.Data, yyxt10)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Cond)); yyxt11 != nil {
				z.EncExtension(x.Cond, yyxt11)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(z.I2Rtid(x.Echo)); yyxt12 != nil {
				z.EncExtension(x.Echo, yyxt12)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt13 := z.Extension(z.I2Rtid(x.Timeout)); yyxt13 != nil {
				z.EncExtension(x.Timeout, yyxt13)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(6)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(z.I2Rtid(x.Data)); yyxt16 != nil {
				z.EncExtension(x.Data, yyxt16)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt17 := z.Extension(z.I2Rtid(x.Cond)); yyxt17 != nil {
				z.EncExtension(x.Cond, yyxt17)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt18 := z.Extension(z.I2Rtid(x.Echo)); yyxt18 != nil {
				z.EncExtension(x.Echo, yyxt18)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt19 := z.Extension(z.I2Rtid(x.Timeout)); yyxt19 != nil {
				z.EncExtension(x.Timeout, yyxt19)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *UpdateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = UpdateStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *UpdateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Data":
			if yyxt6 := z.Extension(z.I2Rtid(x.Data)); yyxt6 != nil {
				z.DecExtension(x.Data, yyxt6)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Cond":
			if yyxt8 := z.Extension(z.I2Rtid(x.Cond)); yyxt8 != nil {
				z.DecExtension(x.Cond, yyxt8)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Echo":
			if yyxt10 := z.Extension(z.I2Rtid(x.Echo)); yyxt10 != nil {
				z.DecExtension(x.Echo, yyxt10)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt12 := z.Extension(z.I2Rtid(x.Timeout)); yyxt12 != nil {
				z.DecExtension(x.Timeout, yyxt12)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UpdateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(z.I2Rtid(x.Data)); yyxt17 != nil {
		z.DecExtension(x.Data, yyxt17)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Cond)); yyxt19 != nil {
		z.DecExtension(x.Cond, yyxt19)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt21 := z.Extension(z.I2Rtid(x.Echo)); yyxt21 != nil {
		z.DecExtension(x.Echo, yyxt21)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt23 := z.Extension(z.I2Rtid(x.Timeout)); yyxt23 != nil {
		z.DecExtension(x.Timeout, yyxt23)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = z.DecCheckBreak()
		}
		if yyb14 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
}

func (x *DeleteStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(z.I2Rtid(x.Cond)); yyxt9 != nil {
				z.EncExtension(x.Cond, yyxt9)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Echo)); yyxt10 != nil {
				z.EncExtension(x.Echo, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Timeout)); yyxt11 != nil {
				z.EncExtension(x.Timeout, yyxt11)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(z.I2Rtid(x.Cond)); yyxt14 != nil {
				z.EncExtension(x.Cond, yyxt14)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt15 := z.Extension(z.I2Rtid(x.Echo)); yyxt15 != nil {
				z.EncExtension(x.Echo, yyxt15)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(z.I2Rtid(x.Timeout)); yyxt16 != nil {
				z.EncExtension(x.Timeout, yyxt16)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *DeleteStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DeleteStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DeleteStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Cond":
			if yyxt6 := z.Extension(z.I2Rtid(x.Cond)); yyxt6 != nil {
				z.DecExtension(x.Cond, yyxt6)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Echo":
			if yyxt8 := z.Extension(z.I2Rtid(x.Echo)); yyxt8 != nil {
				z.DecExtension(x.Echo, yyxt8)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt10 := z.Extension(z.I2Rtid(x.Timeout)); yyxt10 != nil {
				z.DecExtension(x.Timeout, yyxt10)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DeleteStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt15 := z.Extension(z.I2Rtid(x.Cond)); yyxt15 != nil {
		z.DecExtension(x.Cond, yyxt15)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(z.I2Rtid(x.Echo)); yyxt17 != nil {
		z.DecExtension(x.Echo, yyxt17)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Timeout)); yyxt19 != nil {
		z.DecExtension(x.Timeout, yyxt19)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *RelateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(8)
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Type)); yyxt11 != nil {
				z.EncExtension(x.Type, yyxt11)
			} else {
				z.EncFallback(x.Type)
			}
			z.EncWriteArrayElem()
			x.From.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.With.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt14 := z.Extension(z.I2Rtid(x.Data)); yyxt14 != nil {
				z.EncExtension(x.Data, yyxt14)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(z.I2Rtid(x.Echo)); yyxt16 != nil {
				z.EncExtension(x.Echo, yyxt16)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(z.I2Rtid(x.Timeout)); yyxt17 != nil {
				z.EncExtension(x.Timeout, yyxt17)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(8)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			if yyxt19 := z.Extension(z.I2Rtid(x.Type)); yyxt19 != nil {
				z.EncExtension(x.Type, yyxt19)
			} else {
				z.EncFallback(x.Type)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"From\"")
			} else {
				r.EncodeString(`From`)
			}
			z.EncWriteMapElemValue()
			x.From.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"With\"")
			} else {
				r.EncodeString(`With`)
			}
			z.EncWriteMapElemValue()
			x.With.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt22 := z.Extension(z.I2Rtid(x.Data)); yyxt22 != nil {
				z.EncExtension(x.Data, yyxt22)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Uniq\"")
			} else {
				r.EncodeString(`Uniq`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt24 := z.Extension(z.I2Rtid(x.Echo)); yyxt24 != nil {
				z.EncExtension(x.Echo, yyxt24)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt25 := z.Extension(z.I2Rtid(x.Timeout)); yyxt25 != nil {
				z.EncExtension(x.Timeout, yyxt25)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *RelateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RelateStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RelateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Type":
			if yyxt5 := z.Extension(z.I2Rtid(x.Type)); yyxt5 != nil {
				z.DecExtension(x.Type, yyxt5)
			} else {
				z.DecFallback(&x.Type, true)
			}
		case "From":
			x.From.CodecDecodeSelf(d)
		case "With":
			x.With.CodecDecodeSelf(d)
		case "Data":
			if yyxt9 := z.Extension(z.I2Rtid(x.Data)); yyxt9 != nil {
				z.DecExtension(x.Data, yyxt9)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Uniq":
			x.Uniq = (bool)(r.DecodeBool())
		case "Echo":
			if yyxt12 := z.Extension(z.I2Rtid(x.Echo)); yyxt12 != nil {
				z.DecExtension(x.Echo, yyxt12)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt14 := z.Extension(z.I2Rtid(x.Timeout)); yyxt14 != nil {
				z.DecExtension(x.Timeout, yyxt14)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RelateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj16 int
	var yyb16 bool
	var yyhl16 bool = l >= 0
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(z.I2Rtid(x.Type)); yyxt18 != nil {
		z.DecExtension(x.Type, yyxt18)
	} else {
		z.DecFallback(&x.Type, true)
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.From.CodecDecodeSelf(d)
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.With.CodecDecodeSelf(d)
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt22 := z.Extension(z.I2Rtid(x.Data)); yyxt22 != nil {
		z.DecExtension(x.Data, yyxt22)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Uniq = (bool)(r.DecodeBool())
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt25 := z.Extension(z.I2Rtid(x.Echo)); yyxt25 != nil {
		z.DecExtension(x.Echo, yyxt25)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt27 := z.Extension(z.I2Rtid(x.Timeout)); yyxt27 != nil {
		z.DecExtension(x.Timeout, yyxt27)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj16++
	if yyhl16 {
		yyb16 = yyj16 > l
	} else {
		yyb16 = z.DecCheckBreak()
	}
	if yyb16 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj16++
		if yyhl16 {
			yyb16 = yyj16 > l
		} else {
			yyb16 = z.DecCheckBreak()
		}
		if yyb16 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj16-1, "")
	}
}

func (x *InsertStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Into == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Data)); yyxt8 != nil {
				z.EncExtension(x.Data, yyxt8)
			} else {
				z.EncFallback(x.Data)
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Into.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Echo)); yyxt10 != nil {
				z.EncExtension(x.Echo, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Timeout)); yyxt11 != nil {
				z.EncExtension(x.Timeout, yyxt11)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.Data)); yyxt13 != nil {
				z.EncExtension(x.Data, yyxt13)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Into\"")
			} else {
				r.EncodeString(`Into`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Into.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt15 := z.Extension(z.I2Rtid(x.Echo)); yyxt15 != nil {
				z.EncExtension(x.Echo, yyxt15)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(z.I2Rtid(x.Timeout)); yyxt16 != nil {
				z.EncExtension(x.Timeout, yyxt16)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *InsertStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = InsertStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *InsertStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.DecExtension(x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Into":
			if r.TryNil() {
				if x.Into != nil { // remove the if-true
					x.Into = nil
				}
			} else {
				if x.Into == nil {
					x.Into = new(Table)
				}
				x.Into.CodecDecodeSelf(d)
			}
		case "Echo":
			if yyxt8 := z.Extension(z.I2Rtid(x.Echo)); yyxt8 != nil {
				z.DecExtension(x.Echo, yyxt8)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt10 := z.Extension(z.I2Rtid(x.Timeout)); yyxt10 != nil {
				z.DecExtension(x.Timeout, yyxt10)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *InsertStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Data)); yyxt14 != nil {
		z.DecExtension(x.Data, yyxt14)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Into != nil { // remove the if-true
			x.Into = nil
		}
	} else {
		if x.Into == nil {
			x.Into = new(Table)
		}
		x.Into.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(z.I2Rtid(x.Echo)); yyxt17 != nil {
		z.DecExtension(x.Echo, yyxt17)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Timeout)); yyxt19 != nil {
		z.DecExtension(x.Timeout, yyxt19)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *UpsertStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Into == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Data)); yyxt8 != nil {
				z.EncExtension(x.Data, yyxt8)
			} else {
				z.EncFallback(x.Data)
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Into.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Echo)); yyxt10 != nil {
				z.EncExtension(x.Echo, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(z.I2Rtid(x.Timeout)); yyxt11 != nil {
				z.EncExtension(x.Timeout, yyxt11)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.Data)); yyxt13 != nil {
				z.EncExtension(x.Data, yyxt13)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Into\"")
			} else {
				r.EncodeString(`Into`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Into.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt15 := z.Extension(z.I2Rtid(x.Echo)); yyxt15 != nil {
				z.EncExtension(x.Echo, yyxt15)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(z.I2Rtid(x.Timeout)); yyxt16 != nil {
				z.EncExtension(x.Timeout, yyxt16)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Parallel\"")
			} else {
				r.EncodeString(`Parallel`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Parallel))
			z.EncWriteMapEnd()
		}
	}
}

func (x *UpsertStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = UpsertStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *UpsertStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.DecExtension(x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Into":
			if r.TryNil() {
				if x.Into != nil { // remove the if-true
					x.Into = nil
				}
			} else {
				if x.Into == nil {
					x.Into = new(Table)
				}
				x.Into.CodecDecodeSelf(d)
			}
		case "Echo":
			if yyxt8 := z.Extension(z.I2Rtid(x.Echo)); yyxt8 != nil {
				z.DecExtension(x.Echo, yyxt8)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt10 := z.Extension(z.I2Rtid(x.Timeout)); yyxt10 != nil {
				z.DecExtension(x.Timeout, yyxt10)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		case "Parallel":
			x.Parallel = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UpsertStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Data)); yyxt14 != nil {
		z.DecExtension(x.Data, yyxt14)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Into != nil { // remove the if-true
			x.Into = nil
		}
	} else {
		if x.Into == nil {
			x.Into = new(Table)
		}
		x.Into.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(z.I2Rtid(x.Echo)); yyxt17 != nil {
		z.DecExtension(x.Echo, yyxt17)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Timeout)); yyxt19 != nil {
		z.DecExtension(x.Timeout, yyxt19)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Parallel = (bool)(r.DecodeBool())
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *DefineNamespaceStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineNamespaceStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineNamespaceStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineNamespaceStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineNamespaceStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *RemoveNamespaceStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveNamespaceStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveNamespaceStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveNamespaceStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveNamespaceStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *DefineDatabaseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineDatabaseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineDatabaseStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineDatabaseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineDatabaseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *RemoveDatabaseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveDatabaseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveDatabaseStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveDatabaseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveDatabaseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *DefineLoginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.User == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Kind)); yyxt8 != nil {
				z.EncExtension(x.Kind, yyxt8)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.User.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if x.Pass == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Pass))
			} // end block: if x.Pass slice == nil
			z.EncWriteArrayElem()
			if x.Hash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Hash))
			} // end block: if x.Hash slice == nil
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.Kind)); yyxt13 != nil {
				z.EncExtension(x.Kind, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"User\"")
			} else {
				r.EncodeString(`User`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.User.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Pass\"")
			} else {
				r.EncodeString(`Pass`)
			}
			z.EncWriteMapElemValue()
			if x.Pass == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Pass))
			} // end block: if x.Pass slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Hash\"")
			} else {
				r.EncodeString(`Hash`)
			}
			z.EncWriteMapElemValue()
			if x.Hash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Hash))
			} // end block: if x.Hash slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineLoginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineLoginStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineLoginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.DecExtension(x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "User":
			if r.TryNil() {
				if x.User != nil { // remove the if-true
					x.User = nil
				}
			} else {
				if x.User == nil {
					x.User = new(Ident)
				}
				x.User.CodecDecodeSelf(d)
			}
		case "Pass":
			x.Pass = r.DecodeBytes(([]byte)(x.Pass), false)
		case "Hash":
			x.Hash = r.DecodeBytes(([]byte)(x.Hash), false)
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineLoginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj13 int
	var yyb13 bool
	var yyhl13 bool = l >= 0
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt15 := z.Extension(z.I2Rtid(x.Kind)); yyxt15 != nil {
		z.DecExtension(x.Kind, yyxt15)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.User != nil { // remove the if-true
			x.User = nil
		}
	} else {
		if x.User == nil {
			x.User = new(Ident)
		}
		x.User.CodecDecodeSelf(d)
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Pass = r.DecodeBytes(([]byte)(x.Pass), false)
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Hash = r.DecodeBytes(([]byte)(x.Hash), false)
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	for {
		yyj13++
		if yyhl13 {
			yyb13 = yyj13 > l
		} else {
			yyb13 = z.DecCheckBreak()
		}
		if yyb13 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj13-1, "")
	}
}

func (x *RemoveLoginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.User == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.EncExtension(x.Kind, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.User.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt7 := z.Extension(z.I2Rtid(x.Kind)); yyxt7 != nil {
				z.EncExtension(x.Kind, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"User\"")
			} else {
				r.EncodeString(`User`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.User.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveLoginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveLoginStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveLoginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.DecExtension(x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "User":
			if r.TryNil() {
				if x.User != nil { // remove the if-true
					x.User = nil
				}
			} else {
				if x.User == nil {
					x.User = new(Ident)
				}
				x.User.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveLoginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt9 := z.Extension(z.I2Rtid(x.Kind)); yyxt9 != nil {
		z.DecExtension(x.Kind, yyxt9)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.User != nil { // remove the if-true
			x.User = nil
		}
	} else {
		if x.User == nil {
			x.User = new(Ident)
		}
		x.User.CodecDecodeSelf(d)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *DefineTokenStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		var yyn5 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Kind)); yyxt8 != nil {
				z.EncExtension(x.Kind, yyxt8)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Type))
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.Kind)); yyxt13 != nil {
				z.EncExtension(x.Kind, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Type))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineTokenStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineTokenStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineTokenStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.DecExtension(x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				x.What.CodecDecodeSelf(d)
			}
		case "Type":
			x.Type = (string)(string(r.DecodeStringAsBytes()))
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineTokenStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj11 int
	var yyb11 bool
	var yyhl11 bool = l >= 0
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt13 := z.Extension(z.I2Rtid(x.Kind)); yyxt13 != nil {
		z.DecExtension(x.Kind, yyxt13)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		x.What.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Type = (string)(string(r.DecodeStringAsBytes()))
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	for {
		yyj11++
		if yyhl11 {
			yyb11 = yyj11 > l
		} else {
			yyb11 = z.DecCheckBreak()
		}
		if yyb11 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj11-1, "")
	}
}

func (x *RemoveTokenStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		var yyn5 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.Kind)); yyxt6 != nil {
				z.EncExtension(x.Kind, yyxt6)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(z.I2Rtid(x.Kind)); yyxt9 != nil {
				z.EncExtension(x.Kind, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveTokenStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveTokenStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveTokenStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(z.I2Rtid(x.Kind)); yyxt5 != nil {
				z.DecExtension(x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveTokenStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(z.I2Rtid(x.Kind)); yyxt10 != nil {
		z.DecExtension(x.Kind, yyxt10)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *DefineScopeStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(8)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(z.I2Rtid(x.Time)); yyxt12 != nil {
				z.EncExtension(x.Time, yyxt12)
			} else {
				r.EncodeInt(int64(x.Time))
			}
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayElem()
			if yyxt14 := z.Extension(z.I2Rtid(x.Signup)); yyxt14 != nil {
				z.EncExtension(x.Signup, yyxt14)
			} else {
				z.EncFallback(x.Signup)
			}
			z.EncWriteArrayElem()
			if yyxt15 := z.Extension(z.I2Rtid(x.Signin)); yyxt15 != nil {
				z.EncExtension(x.Signin, yyxt15)
			} else {
				z.EncFallback(x.Signin)
			}
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(z.I2Rtid(x.Connect)); yyxt16 != nil {
				z.EncExtension(x.Connect, yyxt16)
			} else {
				z.EncFallback(x.Connect)
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(z.I2Rtid(x.OnSignup)); yyxt17 != nil {
				z.EncExtension(x.OnSignup, yyxt17)
			} else {
				z.EncFallback(x.OnSignup)
			}
			z.EncWriteArrayElem()
			if yyxt18 := z.Extension(z.I2Rtid(x.OnSignin)); yyxt18 != nil {
				z.EncExtension(x.OnSignin, yyxt18)
			} else {
				z.EncFallback(x.OnSignin)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(8)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Time\"")
			} else {
				r.EncodeString(`Time`)
			}
			z.EncWriteMapElemValue()
			if yyxt20 := z.Extension(z.I2Rtid(x.Time)); yyxt20 != nil {
				z.EncExtension(x.Time, yyxt20)
			} else {
				r.EncodeInt(int64(x.Time))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Signup\"")
			} else {
				r.EncodeString(`Signup`)
			}
			z.EncWriteMapElemValue()
			if yyxt22 := z.Extension(z.I2Rtid(x.Signup)); yyxt22 != nil {
				z.EncExtension(x.Signup, yyxt22)
			} else {
				z.EncFallback(x.Signup)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Signin\"")
			} else {
				r.EncodeString(`Signin`)
			}
			z.EncWriteMapElemValue()
			if yyxt23 := z.Extension(z.I2Rtid(x.Signin)); yyxt23 != nil {
				z.EncExtension(x.Signin, yyxt23)
			} else {
				z.EncFallback(x.Signin)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Connect\"")
			} else {
				r.EncodeString(`Connect`)
			}
			z.EncWriteMapElemValue()
			if yyxt24 := z.Extension(z.I2Rtid(x.Connect)); yyxt24 != nil {
				z.EncExtension(x.Connect, yyxt24)
			} else {
				z.EncFallback(x.Connect)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"OnSignup\"")
			} else {
				r.EncodeString(`OnSignup`)
			}
			z.EncWriteMapElemValue()
			if yyxt25 := z.Extension(z.I2Rtid(x.OnSignup)); yyxt25 != nil {
				z.EncExtension(x.OnSignup, yyxt25)
			} else {
				z.EncFallback(x.OnSignup)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"OnSignin\"")
			} else {
				r.EncodeString(`OnSignin`)
			}
			z.EncWriteMapElemValue()
			if yyxt26 := z.Extension(z.I2Rtid(x.OnSignin)); yyxt26 != nil {
				z.EncExtension(x.OnSignin, yyxt26)
			} else {
				z.EncFallback(x.OnSignin)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineScopeStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineScopeStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineScopeStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "Time":
			if yyxt6 := z.Extension(z.I2Rtid(x.Time)); yyxt6 != nil {
				z.DecExtension(x.Time, yyxt6)
			} else {
				x.Time = (time.Duration)(r.DecodeInt64())
			}
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		case "Signup":
			if yyxt10 := z.Extension(z.I2Rtid(x.Signup)); yyxt10 != nil {
				z.DecExtension(x.Signup, yyxt10)
			} else {
				z.DecFallback(&x.Signup, true)
			}
		case "Signin":
			if yyxt12 := z.Extension(z.I2Rtid(x.Signin)); yyxt12 != nil {
				z.DecExtension(x.Signin, yyxt12)
			} else {
				z.DecFallback(&x.Signin, true)
			}
		case "Connect":
			if yyxt14 := z.Extension(z.I2Rtid(x.Connect)); yyxt14 != nil {
				z.DecExtension(x.Connect, yyxt14)
			} else {
				z.DecFallback(&x.Connect, true)
			}
		case "OnSignup":
			if yyxt16 := z.Extension(z.I2Rtid(x.OnSignup)); yyxt16 != nil {
				z.DecExtension(x.OnSignup, yyxt16)
			} else {
				z.DecFallback(&x.OnSignup, true)
			}
		case "OnSignin":
			if yyxt18 := z.Extension(z.I2Rtid(x.OnSignin)); yyxt18 != nil {
				z.DecExtension(x.OnSignin, yyxt18)
			} else {
				z.DecFallback(&x.OnSignin, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineScopeStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj19 int
	var yyb19 bool
	var yyhl19 bool = l >= 0
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt22 := z.Extension(z.I2Rtid(x.Time)); yyxt22 != nil {
		z.DecExtension(x.Time, yyxt22)
	} else {
		x.Time = (time.Duration)(r.DecodeInt64())
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt26 := z.Extension(z.I2Rtid(x.Signup)); yyxt26 != nil {
		z.DecExtension(x.Signup, yyxt26)
	} else {
		z.DecFallback(&x.Signup, true)
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt28 := z.Extension(z.I2Rtid(x.Signin)); yyxt28 != nil {
		z.DecExtension(x.Signin, yyxt28)
	} else {
		z.DecFallback(&x.Signin, true)
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(z.I2Rtid(x.Connect)); yyxt30 != nil {
		z.DecExtension(x.Connect, yyxt30)
	} else {
		z.DecFallback(&x.Connect, true)
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt32 := z.Extension(z.I2Rtid(x.OnSignup)); yyxt32 != nil {
		z.DecExtension(x.OnSignup, yyxt32)
	} else {
		z.DecFallback(&x.OnSignup, true)
	}
	yyj19++
	if yyhl19 {
		yyb19 = yyj19 > l
	} else {
		yyb19 = z.DecCheckBreak()
	}
	if yyb19 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt34 := z.Extension(z.I2Rtid(x.OnSignin)); yyxt34 != nil {
		z.DecExtension(x.OnSignin, yyxt34)
	} else {
		z.DecFallback(&x.OnSignin, true)
	}
	for {
		yyj19++
		if yyhl19 {
			yyb19 = yyj19 > l
		} else {
			yyb19 = z.DecCheckBreak()
		}
		if yyb19 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj19-1, "")
	}
}

func (x *RemoveScopeStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveScopeStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveScopeStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveScopeStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveScopeStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *DefineTableStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(11)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Full))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Vers))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Drop))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Lock))
			z.EncWriteArrayElem()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.From.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt22 := z.Extension(z.I2Rtid(x.Cond)); yyxt22 != nil {
				z.EncExtension(x.Cond, yyxt22)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			x.Group.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt24 := z.Extension(z.I2Rtid(x.Perms)); yyxt24 != nil {
				z.EncExtension(x.Perms, yyxt24)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(11)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Full\"")
			} else {
				r.EncodeString(`Full`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Full))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Vers\"")
			} else {
				r.EncodeString(`Vers`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Vers))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Drop\"")
			} else {
				r.EncodeString(`Drop`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Drop))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Lock\"")
			} else {
				r.EncodeString(`Lock`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Lock))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"From\"")
			} else {
				r.EncodeString(`From`)
			}
			z.EncWriteMapElemValue()
			x.From.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt33 := z.Extension(z.I2Rtid(x.Cond)); yyxt33 != nil {
				z.EncExtension(x.Cond, yyxt33)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Group\"")
			} else {
				r.EncodeString(`Group`)
			}
			z.EncWriteMapElemValue()
			x.Group.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Perms\"")
			} else {
				r.EncodeString(`Perms`)
			}
			z.EncWriteMapElemValue()
			if yyxt35 := z.Extension(z.I2Rtid(x.Perms)); yyxt35 != nil {
				z.EncExtension(x.Perms, yyxt35)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineTableStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineTableStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineTableStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Full":
			x.Full = (bool)(r.DecodeBool())
		case "Vers":
			x.Vers = (bool)(r.DecodeBool())
		case "Drop":
			x.Drop = (bool)(r.DecodeBool())
		case "Lock":
			x.Lock = (bool)(r.DecodeBool())
		case "Expr":
			x.Expr.CodecDecodeSelf(d)
		case "From":
			x.From.CodecDecodeSelf(d)
		case "Cond":
			if yyxt13 := z.Extension(z.I2Rtid(x.Cond)); yyxt13 != nil {
				z.DecExtension(x.Cond, yyxt13)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Group":
			x.Group.CodecDecodeSelf(d)
		case "Perms":
			if yyxt16 := z.Extension(z.I2Rtid(x.Perms)); yyxt16 != nil {
				z.DecExtension(x.Perms, yyxt16)
			} else {
				z.DecFallback(&x.Perms, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineTableStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Full = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Vers = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Drop = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Lock = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Expr.CodecDecodeSelf(d)
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.From.CodecDecodeSelf(d)
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt27 := z.Extension(z.I2Rtid(x.Cond)); yyxt27 != nil {
		z.DecExtension(x.Cond, yyxt27)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Group.CodecDecodeSelf(d)
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(z.I2Rtid(x.Perms)); yyxt30 != nil {
		z.DecExtension(x.Perms, yyxt30)
	} else {
		z.DecFallback(&x.Perms, true)
	}
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = z.DecCheckBreak()
		}
		if yyb17 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj17-1, "")
	}
}

func (x *RemoveTableStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveTableStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveTableStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveTableStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveTableStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *DefineEventStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(z.I2Rtid(x.When)); yyxt9 != nil {
				z.EncExtension(x.When, yyxt9)
			} else {
				z.EncFallback(x.When)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Then)); yyxt10 != nil {
				z.EncExtension(x.Then, yyxt10)
			} else {
				z.EncFallback(x.Then)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"When\"")
			} else {
				r.EncodeString(`When`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.When)); yyxt13 != nil {
				z.EncExtension(x.When, yyxt13)
			} else {
				z.EncFallback(x.When)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Then\"")
			} else {
				r.EncodeString(`Then`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(z.I2Rtid(x.Then)); yyxt14 != nil {
				z.EncExtension(x.Then, yyxt14)
			} else {
				z.EncFallback(x.Then)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineEventStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineEventStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineEventStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		case "When":
			if yyxt7 := z.Extension(z.I2Rtid(x.When)); yyxt7 != nil {
				z.DecExtension(x.When, yyxt7)
			} else {
				z.DecFallback(&x.When, true)
			}
		case "Then":
			if yyxt9 := z.Extension(z.I2Rtid(x.Then)); yyxt9 != nil {
				z.DecExtension(x.Then, yyxt9)
			} else {
				z.DecFallback(&x.Then, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineEventStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.When)); yyxt14 != nil {
		z.DecExtension(x.When, yyxt14)
	} else {
		z.DecFallback(&x.When, true)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(z.I2Rtid(x.Then)); yyxt16 != nil {
		z.DecExtension(x.Then, yyxt16)
	} else {
		z.DecFallback(&x.Then, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *RemoveEventStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveEventStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveEventStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveEventStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveEventStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DefineFieldStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(8)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			if yyxt13 := z.Extension(z.I2Rtid(x.Perms)); yyxt13 != nil {
				z.EncExtension(x.Perms, yyxt13)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Type))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Kind))
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(z.I2Rtid(x.Value)); yyxt16 != nil {
				z.EncExtension(x.Value, yyxt16)
			} else {
				z.EncFallback(x.Value)
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(z.I2Rtid(x.Assert)); yyxt17 != nil {
				z.EncExtension(x.Assert, yyxt17)
			} else {
				z.EncFallback(x.Assert)
			}
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.Priority))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(8)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Perms\"")
			} else {
				r.EncodeString(`Perms`)
			}
			z.EncWriteMapElemValue()
			if yyxt21 := z.Extension(z.I2Rtid(x.Perms)); yyxt21 != nil {
				z.EncExtension(x.Perms, yyxt21)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Type))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Kind))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Value\"")
			} else {
				r.EncodeString(`Value`)
			}
			z.EncWriteMapElemValue()
			if yyxt24 := z.Extension(z.I2Rtid(x.Value)); yyxt24 != nil {
				z.EncExtension(x.Value, yyxt24)
			} else {
				z.EncFallback(x.Value)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Assert\"")
			} else {
				r.EncodeString(`Assert`)
			}
			z.EncWriteMapElemValue()
			if yyxt25 := z.Extension(z.I2Rtid(x.Assert)); yyxt25 != nil {
				z.EncExtension(x.Assert, yyxt25)
			} else {
				z.EncFallback(x.Assert)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Priority\"")
			} else {
				r.EncodeString(`Priority`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.Priority))
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineFieldStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineFieldStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineFieldStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Perms":
			if yyxt7 := z.Extension(z.I2Rtid(x.Perms)); yyxt7 != nil {
				z.DecExtension(x.Perms, yyxt7)
			} else {
				z.DecFallback(&x.Perms, true)
			}
		case "Type":
			x.Type = (string)(string(r.DecodeStringAsBytes()))
		case "Kind":
			x.Kind = (string)(string(r.DecodeStringAsBytes()))
		case "Value":
			if yyxt11 := z.Extension(z.I2Rtid(x.Value)); yyxt11 != nil {
				z.DecExtension(x.Value, yyxt11)
			} else {
				z.DecFallback(&x.Value, true)
			}
		case "Assert":
			if yyxt13 := z.Extension(z.I2Rtid(x.Assert)); yyxt13 != nil {
				z.DecExtension(x.Assert, yyxt13)
			} else {
				z.DecFallback(&x.Assert, true)
			}
		case "Priority":
			x.Priority = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineFieldStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj15 int
	var yyb15 bool
	var yyhl15 bool = l >= 0
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(z.I2Rtid(x.Perms)); yyxt19 != nil {
		z.DecExtension(x.Perms, yyxt19)
	} else {
		z.DecFallback(&x.Perms, true)
	}
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Type = (string)(string(r.DecodeStringAsBytes()))
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Kind = (string)(string(r.DecodeStringAsBytes()))
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt23 := z.Extension(z.I2Rtid(x.Value)); yyxt23 != nil {
		z.DecExtension(x.Value, yyxt23)
	} else {
		z.DecFallback(&x.Value, true)
	}
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt25 := z.Extension(z.I2Rtid(x.Assert)); yyxt25 != nil {
		z.DecExtension(x.Assert, yyxt25)
	} else {
		z.DecFallback(&x.Assert, true)
	}
	yyj15++
	if yyhl15 {
		yyb15 = yyj15 > l
	} else {
		yyb15 = z.DecCheckBreak()
	}
	if yyb15 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Priority = (float64)(r.DecodeFloat64())
	for {
		yyj15++
		if yyhl15 {
			yyb15 = yyj15 > l
		} else {
			yyb15 = z.DecCheckBreak()
		}
		if yyb15 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj15-1, "")
	}
}

func (x *RemoveFieldStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveFieldStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveFieldStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveFieldStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveFieldStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DefineIndexStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			x.Cols.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cols\"")
			} else {
				r.EncodeString(`Cols`)
			}
			z.EncWriteMapElemValue()
			x.Cols.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Uniq\"")
			} else {
				r.EncodeString(`Uniq`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineIndexStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DefineIndexStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DefineIndexStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Cols":
			x.Cols.CodecDecodeSelf(d)
		case "Uniq":
			x.Uniq = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineIndexStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Cols.CodecDecodeSelf(d)
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Uniq = (bool)(r.DecodeBool())
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *RemoveIndexStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveIndexStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = RemoveIndexStatement{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *RemoveIndexStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "What":
			x.What.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveIndexStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Exprs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encExprs((Exprs)(x), e)
	} // end block: if x slice == nil
}

func (x *Exprs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decExprs((*Exprs)(x), d)
}

func (x *All) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *All) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = All{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *All) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *All) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Any) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Any) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Any{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Any) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Any) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Null) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Null) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Null{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Null) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Null) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Void) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Void) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Void{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Void) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Void) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Empty) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Empty) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Empty{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Empty) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Empty) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Field) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.Expr)); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Field))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Alias))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(z.I2Rtid(x.Expr)); yyxt9 != nil {
				z.EncExtension(x.Expr, yyxt9)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Field\"")
			} else {
				r.EncodeString(`Field`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Field))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Alias\"")
			} else {
				r.EncodeString(`Alias`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Alias))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Field) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Field{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Field) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.DecExtension(x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		case "Field":
			x.Field = (string)(string(r.DecodeStringAsBytes()))
		case "Alias":
			x.Alias = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Field) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(z.I2Rtid(x.Expr)); yyxt10 != nil {
		z.DecExtension(x.Expr, yyxt10)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Field = (string)(string(r.DecodeStringAsBytes()))
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Alias = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x Fields) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encFields((Fields)(x), e)
	} // end block: if x slice == nil
}

func (x *Fields) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decFields((*Fields)(x), d)
}

func (x *Group) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Expr)); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Group) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Group{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Group) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.DecExtension(x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Group) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Expr)); yyxt8 != nil {
		z.DecExtension(x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Groups) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encGroups((Groups)(x), e)
	} // end block: if x slice == nil
}

func (x *Groups) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decGroups((*Groups)(x), d)
}

func (x *Order) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.Expr)); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Dir))
			z.EncWriteArrayElem()
			yy8 := &x.Tag
			if yyxt9 := z.Extension(z.I2Rtid(yy8)); yyxt9 != nil {
				z.EncExtension(yy8, yyxt9)
			} else if !z.EncBinary() {
				z.EncTextMarshal(yy8)
			} else {
				z.EncFallback(yy8)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(z.I2Rtid(x.Expr)); yyxt10 != nil {
				z.EncExtension(x.Expr, yyxt10)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Dir\"")
			} else {
				r.EncodeString(`Dir`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Dir))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Tag\"")
			} else {
				r.EncodeString(`Tag`)
			}
			z.EncWriteMapElemValue()
			yy12 := &x.Tag
			if yyxt13 := z.Extension(z.I2Rtid(yy12)); yyxt13 != nil {
				z.EncExtension(yy12, yyxt13)
			} else if !z.EncBinary() {
				z.EncTextMarshal(yy12)
			} else {
				z.EncFallback(yy12)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Order) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Order{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Order) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.DecExtension(x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		case "Dir":
			x.Dir = (bool)(r.DecodeBool())
		case "Tag":
			if yyxt8 := z.Extension(z.I2Rtid(x.Tag)); yyxt8 != nil {
				z.DecExtension(x.Tag, yyxt8)
			} else if !z.DecBinary() {
				z.DecTextUnmarshal(&x.Tag)
			} else {
				z.DecFallback(&x.Tag, false)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Order) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt11 := z.Extension(z.I2Rtid(x.Expr)); yyxt11 != nil {
		z.DecExtension(x.Expr, yyxt11)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Dir = (bool)(r.DecodeBool())
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Tag)); yyxt14 != nil {
		z.DecExtension(x.Tag, yyxt14)
	} else if !z.DecBinary() {
		z.DecTextUnmarshal(&x.Tag)
	} else {
		z.DecFallback(&x.Tag, false)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x Orders) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encOrders((Orders)(x), e)
	} // end block: if x slice == nil
}

func (x *Orders) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decOrders((*Orders)(x), d)
}

func (x *Fetch) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Expr)); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Fetch) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Fetch{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Fetch) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.DecExtension(x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Fetch) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Expr)); yyxt8 != nil {
		z.DecExtension(x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Fetchs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encFetchs((Fetchs)(x), e)
	} // end block: if x slice == nil
}

func (x *Fetchs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decFetchs((*Fetchs)(x), d)
}

func (x *SubExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Expr)); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SubExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = SubExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *SubExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(z.I2Rtid(x.Expr)); yyxt5 != nil {
				z.DecExtension(x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SubExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Expr)); yyxt8 != nil {
		z.DecExtension(x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *MultExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Expr == nil {
				r.EncodeNil()
			} else {
				h.encSliceExpr(([]Expr)(x.Expr), e)
			} // end block: if x.Expr slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if x.Expr == nil {
				r.EncodeNil()
			} else {
				h.encSliceExpr(([]Expr)(x.Expr), e)
			} // end block: if x.Expr slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *MultExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = MultExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *MultExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			h.decSliceExpr((*[]Expr)(&x.Expr), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *MultExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSliceExpr((*[]Expr)(&x.Expr), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *FuncExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Name))
			z.EncWriteArrayElem()
			x.Args.CodecEncodeSelf(e)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Aggr))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Name))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Args\"")
			} else {
				r.EncodeString(`Args`)
			}
			z.EncWriteMapElemValue()
			x.Args.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Aggr\"")
			} else {
				r.EncodeString(`Aggr`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Aggr))
			z.EncWriteMapEnd()
		}
	}
}

func (x *FuncExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = FuncExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *FuncExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			x.Name = (string)(string(r.DecodeStringAsBytes()))
		case "Args":
			x.Args.CodecDecodeSelf(d)
		case "Aggr":
			x.Aggr = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *FuncExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Name = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Args.CodecDecodeSelf(d)
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Aggr = (bool)(r.DecodeBool())
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *ItemExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.LHS)); yyxt6 != nil {
				z.EncExtension(x.LHS, yyxt6)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(z.I2Rtid(x.Op)); yyxt7 != nil {
				z.EncExtension(x.Op, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.RHS)); yyxt8 != nil {
				z.EncExtension(x.RHS, yyxt8)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"LHS\"")
			} else {
				r.EncodeString(`LHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(z.I2Rtid(x.LHS)); yyxt9 != nil {
				z.EncExtension(x.LHS, yyxt9)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Op\"")
			} else {
				r.EncodeString(`Op`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(z.I2Rtid(x.Op)); yyxt10 != nil {
				z.EncExtension(x.Op, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RHS\"")
			} else {
				r.EncodeString(`RHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(z.I2Rtid(x.RHS)); yyxt11 != nil {
				z.EncExtension(x.RHS, yyxt11)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *ItemExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = ItemExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *ItemExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LHS":
			if yyxt5 := z.Extension(z.I2Rtid(x.LHS)); yyxt5 != nil {
				z.DecExtension(x.LHS, yyxt5)
			} else {
				z.DecFallback(&x.LHS, true)
			}
		case "Op":
			if yyxt7 := z.Extension(z.I2Rtid(x.Op)); yyxt7 != nil {
				z.DecExtension(x.Op, yyxt7)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Op)
			} else {
				x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "RHS":
			if yyxt9 := z.Extension(z.I2Rtid(x.RHS)); yyxt9 != nil {
				z.DecExtension(x.RHS, yyxt9)
			} else {
				z.DecFallback(&x.RHS, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ItemExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(z.I2Rtid(x.LHS)); yyxt12 != nil {
		z.DecExtension(x.LHS, yyxt12)
	} else {
		z.DecFallback(&x.LHS, true)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Op)); yyxt14 != nil {
		z.DecExtension(x.Op, yyxt14)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Op)
	} else {
		x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(z.I2Rtid(x.RHS)); yyxt16 != nil {
		z.DecExtension(x.RHS, yyxt16)
	} else {
		z.DecFallback(&x.RHS, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *BinaryExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(z.I2Rtid(x.LHS)); yyxt6 != nil {
				z.EncExtension(x.LHS, yyxt6)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(z.I2Rtid(x.Op)); yyxt7 != nil {
				z.EncExtension(x.Op, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.RHS)); yyxt8 != nil {
				z.EncExtension(x.RHS, yyxt8)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"LHS\"")
			} else {
				r.EncodeString(`LHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(z.I2Rtid(x.LHS)); yyxt9 != nil {
				z.EncExtension(x.LHS, yyxt9)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Op\"")
			} else {
				r.EncodeString(`Op`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(z.I2Rtid(x.Op)); yyxt10 != nil {
				z.EncExtension(x.Op, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RHS\"")
			} else {
				r.EncodeString(`RHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(z.I2Rtid(x.RHS)); yyxt11 != nil {
				z.EncExtension(x.RHS, yyxt11)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *BinaryExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = BinaryExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *BinaryExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LHS":
			if yyxt5 := z.Extension(z.I2Rtid(x.LHS)); yyxt5 != nil {
				z.DecExtension(x.LHS, yyxt5)
			} else {
				z.DecFallback(&x.LHS, true)
			}
		case "Op":
			if yyxt7 := z.Extension(z.I2Rtid(x.Op)); yyxt7 != nil {
				z.DecExtension(x.Op, yyxt7)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Op)
			} else {
				x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "RHS":
			if yyxt9 := z.Extension(z.I2Rtid(x.RHS)); yyxt9 != nil {
				z.DecExtension(x.RHS, yyxt9)
			} else {
				z.DecFallback(&x.RHS, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BinaryExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(z.I2Rtid(x.LHS)); yyxt12 != nil {
		z.DecExtension(x.LHS, yyxt12)
	} else {
		z.DecFallback(&x.LHS, true)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Op)); yyxt14 != nil {
		z.DecExtension(x.Op, yyxt14)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Op)
	} else {
		x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(z.I2Rtid(x.RHS)); yyxt16 != nil {
		z.DecExtension(x.RHS, yyxt16)
	} else {
		z.DecFallback(&x.RHS, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *PathExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			x.Expr.CodecEncodeSelf(e)
			z.EncWriteMapEnd()
		}
	}
}

func (x *PathExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = PathExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *PathExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			x.Expr.CodecDecodeSelf(d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PathExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Expr.CodecDecodeSelf(d)
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *PartExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Part)); yyxt4 != nil {
				z.EncExtension(x.Part, yyxt4)
			} else {
				z.EncFallback(x.Part)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Part\"")
			} else {
				r.EncodeString(`Part`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Part)); yyxt5 != nil {
				z.EncExtension(x.Part, yyxt5)
			} else {
				z.EncFallback(x.Part)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *PartExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = PartExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *PartExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Part":
			if yyxt5 := z.Extension(z.I2Rtid(x.Part)); yyxt5 != nil {
				z.DecExtension(x.Part, yyxt5)
			} else {
				z.DecFallback(&x.Part, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PartExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Part)); yyxt8 != nil {
		z.DecExtension(x.Part, yyxt8)
	} else {
		z.DecFallback(&x.Part, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *JoinExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Join)); yyxt4 != nil {
				z.EncExtension(x.Join, yyxt4)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Join)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Join)
			} else {
				r.EncodeInt(int64(x.Join))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Join\"")
			} else {
				r.EncodeString(`Join`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Join)); yyxt5 != nil {
				z.EncExtension(x.Join, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Join)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Join)
			} else {
				r.EncodeInt(int64(x.Join))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *JoinExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = JoinExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *JoinExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Join":
			if yyxt5 := z.Extension(z.I2Rtid(x.Join)); yyxt5 != nil {
				z.DecExtension(x.Join, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Join)
			} else {
				x.Join = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *JoinExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Join)); yyxt8 != nil {
		z.DecExtension(x.Join, yyxt8)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Join)
	} else {
		x.Join = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *SubpExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			x.What.CodecEncodeSelf(e)
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Cond)); yyxt8 != nil {
				z.EncExtension(x.Cond, yyxt8)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			x.What.CodecEncodeSelf(e)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				x.Name.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(z.I2Rtid(x.Cond)); yyxt11 != nil {
				z.EncExtension(x.Cond, yyxt11)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SubpExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = SubpExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *SubpExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			x.What.CodecDecodeSelf(d)
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				x.Name.CodecDecodeSelf(d)
			}
		case "Cond":
			if yyxt7 := z.Extension(z.I2Rtid(x.Cond)); yyxt7 != nil {
				z.DecExtension(x.Cond, yyxt7)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SubpExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What.CodecDecodeSelf(d)
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		x.Name.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(z.I2Rtid(x.Cond)); yyxt12 != nil {
		z.DecExtension(x.Cond, yyxt12)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *PermExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(z.I2Rtid(x.Select)); yyxt7 != nil {
				z.EncExtension(x.Select, yyxt7)
			} else {
				z.EncFallback(x.Select)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(z.I2Rtid(x.Create)); yyxt8 != nil {
				z.EncExtension(x.Create, yyxt8)
			} else {
				z.EncFallback(x.Create)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(z.I2Rtid(x.Update)); yyxt9 != nil {
				z.EncExtension(x.Update, yyxt9)
			} else {
				z.EncFallback(x.Update)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(z.I2Rtid(x.Delete)); yyxt10 != nil {
				z.EncExtension(x.Delete, yyxt10)
			} else {
				z.EncFallback(x.Delete)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Select\"")
			} else {
				r.EncodeString(`Select`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(z.I2Rtid(x.Select)); yyxt11 != nil {
				z.EncExtension(x.Select, yyxt11)
			} else {
				z.EncFallback(x.Select)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Create\"")
			} else {
				r.EncodeString(`Create`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(z.I2Rtid(x.Create)); yyxt12 != nil {
				z.EncExtension(x.Create, yyxt12)
			} else {
				z.EncFallback(x.Create)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Update\"")
			} else {
				r.EncodeString(`Update`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(z.I2Rtid(x.Update)); yyxt13 != nil {
				z.EncExtension(x.Update, yyxt13)
			} else {
				z.EncFallback(x.Update)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Delete\"")
			} else {
				r.EncodeString(`Delete`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(z.I2Rtid(x.Delete)); yyxt14 != nil {
				z.EncExtension(x.Delete, yyxt14)
			} else {
				z.EncFallback(x.Delete)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *PermExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = PermExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *PermExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Select":
			if yyxt5 := z.Extension(z.I2Rtid(x.Select)); yyxt5 != nil {
				z.DecExtension(x.Select, yyxt5)
			} else {
				z.DecFallback(&x.Select, true)
			}
		case "Create":
			if yyxt7 := z.Extension(z.I2Rtid(x.Create)); yyxt7 != nil {
				z.DecExtension(x.Create, yyxt7)
			} else {
				z.DecFallback(&x.Create, true)
			}
		case "Update":
			if yyxt9 := z.Extension(z.I2Rtid(x.Update)); yyxt9 != nil {
				z.DecExtension(x.Update, yyxt9)
			} else {
				z.DecFallback(&x.Update, true)
			}
		case "Delete":
			if yyxt11 := z.Extension(z.I2Rtid(x.Delete)); yyxt11 != nil {
				z.DecExtension(x.Delete, yyxt11)
			} else {
				z.DecFallback(&x.Delete, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PermExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(z.I2Rtid(x.Select)); yyxt14 != nil {
		z.DecExtension(x.Select, yyxt14)
	} else {
		z.DecFallback(&x.Select, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(z.I2Rtid(x.Create)); yyxt16 != nil {
		z.DecExtension(x.Create, yyxt16)
	} else {
		z.DecFallback(&x.Create, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(z.I2Rtid(x.Update)); yyxt18 != nil {
		z.DecExtension(x.Update, yyxt18)
	} else {
		z.DecFallback(&x.Update, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(z.I2Rtid(x.Delete)); yyxt20 != nil {
		z.DecExtension(x.Delete, yyxt20)
	} else {
		z.DecFallback(&x.Delete, true)
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *DataExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoItemExpression(([]*ItemExpression)(x.Data), e)
			} // end block: if x.Data slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoItemExpression(([]*ItemExpression)(x.Data), e)
			} // end block: if x.Data slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DataExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DataExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DataExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			h.decSlicePtrtoItemExpression((*[]*ItemExpression)(&x.Data), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DataExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoItemExpression((*[]*ItemExpression)(&x.Data), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DiffExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Data)); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DiffExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = DiffExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *DiffExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.DecExtension(x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DiffExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Data)); yyxt8 != nil {
		z.DecExtension(x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *MergeExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Data)); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *MergeExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = MergeExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *MergeExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.DecExtension(x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *MergeExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Data)); yyxt8 != nil {
		z.DecExtension(x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *ContentExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(z.I2Rtid(x.Data)); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *ContentExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = ContentExpression{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *ContentExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(z.I2Rtid(x.Data)); yyxt5 != nil {
				z.DecExtension(x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ContentExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(z.I2Rtid(x.Data)); yyxt8 != nil {
		z.DecExtension(x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Params) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encParams((Params)(x), e)
	} // end block: if x slice == nil
}

func (x *Params) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decParams((*Params)(x), d)
}

func (x *Param) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Param) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Param{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Param) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Param) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Idents) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encIdents((Idents)(x), e)
	} // end block: if x slice == nil
}

func (x *Idents) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decIdents((*Idents)(x), d)
}

func (x *Ident) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Ident) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Ident{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Ident) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Ident) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Values) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encValues((Values)(x), e)
	} // end block: if x slice == nil
}

func (x *Values) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decValues((*Values)(x), d)
}

func (x *Value) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Value) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Value{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Value) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Value) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Regexs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encRegexs((Regexs)(x), e)
	} // end block: if x slice == nil
}

func (x *Regexs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decRegexs((*Regexs)(x), d)
}

func (x *Regex) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Regex) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Regex{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Regex) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Regex) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Tables) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encTables((Tables)(x), e)
	} // end block: if x slice == nil
}

func (x *Tables) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decTables((*Tables)(x), d)
}

func (x *Table) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Table) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Table{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Table) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Table) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x Batchs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encBatchs((Batchs)(x), e)
	} // end block: if x slice == nil
}

func (x *Batchs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decBatchs((*Batchs)(x), d)
}

func (x *Batch) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayElem()
			if x.BA == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoThing(([]*Thing)(x.BA), e)
			} // end block: if x.BA slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BA\"")
			} else {
				r.EncodeString(`BA`)
			}
			z.EncWriteMapElemValue()
			if x.BA == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoThing(([]*Thing)(x.BA), e)
			} // end block: if x.BA slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *Batch) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Batch{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Batch) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "BA":
			h.decSlicePtrtoThing((*[]*Thing)(&x.BA), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Batch) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoThing((*[]*Thing)(&x.BA), d)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x Models) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encModels((Models)(x), e)
	} // end block: if x slice == nil
}

func (x *Models) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decModels((*Models)(x), d)
}

func (x *Model) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.MIN))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.INC))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.MAX))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MIN\"")
			} else {
				r.EncodeString(`MIN`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.MIN))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"INC\"")
			} else {
				r.EncodeString(`INC`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.INC))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MAX\"")
			} else {
				r.EncodeString(`MAX`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.MAX))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Model) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Model{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Model) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "MIN":
			x.MIN = (float64)(r.DecodeFloat64())
		case "INC":
			x.INC = (float64)(r.DecodeFloat64())
		case "MAX":
			x.MAX = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Model) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.MIN = (float64)(r.DecodeFloat64())
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.INC = (float64)(r.DecodeFloat64())
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.MAX = (float64)(r.DecodeFloat64())
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x Things) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encThings((Things)(x), e)
	} // end block: if x slice == nil
}

func (x *Things) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decThings((*Things)(x), d)
}

func (x *Thing) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yysep2 := !z.EncBinary()
		yy2arr2 := z.EncBasicHandle().StructToArray
		_, _ = yysep2, yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayElem()
			z.EncFallback(x.ID)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ID\"")
			} else {
				r.EncodeString(`ID`)
			}
			z.EncWriteMapElemValue()
			z.EncFallback(x.ID)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Thing) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Thing{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Thing) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "ID":
			z.DecFallback(&x.ID, true)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Thing) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.DecFallback(&x.ID, true)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x Points) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encPoints((Points)(x), e)
	} // end block: if x slice == nil
}

func (x *Points) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decPoints((*Points)(x), d)
}

func (x *Point) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(x)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(2)
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.LA))
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.LO))
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(2)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"LA\"")
				} else {
					r.EncodeString(`LA`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.LA))
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"LO\"")
				} else {
					r.EncodeString(`LO`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.LO))
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Point) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Point{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Point) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LA":
			x.LA = (float64)(r.DecodeFloat64())
		case "LO":
			x.LO = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Point) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.LA = (float64)(r.DecodeFloat64())
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.LO = (float64)(r.DecodeFloat64())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Circles) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encCircles((Circles)(x), e)
	} // end block: if x slice == nil
}

func (x *Circles) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decCircles((*Circles)(x), d)
}

func (x *Circle) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(x)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			var yyn3 bool = x.CE == nil
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(2)
				if yyn3 {
					z.EncWriteArrayElem()
					r.EncodeNil()
				} else {
					z.EncWriteArrayElem()
					x.CE.CodecEncodeSelf(e)
				}
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.RA))
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(2)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"CE\"")
				} else {
					r.EncodeString(`CE`)
				}
				z.EncWriteMapElemValue()
				if yyn3 {
					r.EncodeNil()
				} else {
					x.CE.CodecEncodeSelf(e)
				}
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"RA\"")
				} else {
					r.EncodeString(`RA`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.RA))
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Circle) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Circle{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Circle) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "CE":
			if r.TryNil() {
				if x.CE != nil { // remove the if-true
					x.CE = nil
				}
			} else {
				if x.CE == nil {
					x.CE = new(Point)
				}
				x.CE.CodecDecodeSelf(d)
			}
		case "RA":
			x.RA = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Circle) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.CE != nil { // remove the if-true
			x.CE = nil
		}
	} else {
		if x.CE == nil {
			x.CE = new(Point)
		}
		x.CE.CodecDecodeSelf(d)
	}
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RA = (float64)(r.DecodeFloat64())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x Polygons) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encPolygons((Polygons)(x), e)
	} // end block: if x slice == nil
}

func (x *Polygons) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	h.decPolygons((*Polygons)(x), d)
}

func (x *Polygon) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(x)
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			_, _ = yysep2, yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(1)
				z.EncWriteArrayElem()
				if x.PS == nil {
					r.EncodeNil()
				} else {
					h.encSlicePtrtoPoint(([]*Point)(x.PS), e)
				} // end block: if x.PS slice == nil
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(1)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"PS\"")
				} else {
					r.EncodeString(`PS`)
				}
				z.EncWriteMapElemValue()
				if x.PS == nil {
					r.EncodeNil()
				} else {
					h.encSlicePtrtoPoint(([]*Point)(x.PS), e)
				} // end block: if x.PS slice == nil
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Polygon) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil7834 {
		*(x) = Polygon{}
	} else if yyct2 == codecSelferValueTypeMap7834 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray7834 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct7834)
	}
}

func (x *Polygon) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "PS":
			h.decSlicePtrtoPoint((*[]*Point)(&x.PS), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Polygon) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoPoint((*[]*Point)(&x.PS), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x codecSelfer7834) encStatements(v Statements, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(z.I2Rtid(yyv1)); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decStatements(v *Statements, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Statement{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Statement, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Statement, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(z.I2Rtid(yyv1[yyj1])); yyxt3 != nil {
					z.DecExtension(yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Statement, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encExprs(v Exprs, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(z.I2Rtid(yyv1)); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decExprs(v *Exprs, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Expr{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Expr, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Expr, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(z.I2Rtid(yyv1[yyj1])); yyxt3 != nil {
					z.DecExtension(yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Expr, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encFields(v Fields, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decFields(v *Fields, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Field{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Field, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Field, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Field)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Field, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encGroups(v Groups, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decGroups(v *Groups, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Group{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Group, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Group, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Group)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Group, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encOrders(v Orders, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decOrders(v *Orders, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Order{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Order, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Order, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Order)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Order, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encFetchs(v Fetchs, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decFetchs(v *Fetchs, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Fetch{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Fetch, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Fetch, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Fetch)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Fetch, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encSliceExpr(v []Expr, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(z.I2Rtid(yyv1)); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decSliceExpr(v *[]Expr, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Expr{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Expr, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Expr, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(z.I2Rtid(yyv1[yyj1])); yyxt3 != nil {
					z.DecExtension(yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Expr, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encSlicePtrtoItemExpression(v []*ItemExpression, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decSlicePtrtoItemExpression(v *[]*ItemExpression, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*ItemExpression{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*ItemExpression, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*ItemExpression, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(ItemExpression)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*ItemExpression, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encParams(v Params, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decParams(v *Params, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Param{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Param, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Param, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Param)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Param, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encIdents(v Idents, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decIdents(v *Idents, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Ident{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Ident, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Ident, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Ident)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Ident, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encValues(v Values, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decValues(v *Values, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Value{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Value, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Value, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Value)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Value, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encRegexs(v Regexs, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decRegexs(v *Regexs, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Regex{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Regex, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Regex, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Regex)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Regex, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encTables(v Tables, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decTables(v *Tables, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Table{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Table, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Table, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Table)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Table, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encBatchs(v Batchs, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decBatchs(v *Batchs, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Batch{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Batch, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Batch, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Batch)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Batch, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encSlicePtrtoThing(v []*Thing, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decSlicePtrtoThing(v *[]*Thing, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Thing{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Thing, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Thing, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Thing)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Thing, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encModels(v Models, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decModels(v *Models, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Model{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Model, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Model, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Model)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Model, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encThings(v Things, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decThings(v *Things, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Thing{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Thing, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Thing, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Thing)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Thing, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encPoints(v Points, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decPoints(v *Points, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Point{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Point, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Point, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Point)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Point, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encCircles(v Circles, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decCircles(v *Circles, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Circle{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Circle, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Circle, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Circle)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Circle, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encPolygons(v Polygons, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decPolygons(v *Polygons, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Polygon{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Polygon, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Polygon, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Polygon)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Polygon, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer7834) encSlicePtrtoPoint(v []*Point, e *codec1978.Encoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			yyv1.CodecEncodeSelf(e)
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer7834) decSlicePtrtoPoint(v *[]*Point, d *codec1978.Decoder) {
	var h codecSelfer7834
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Point{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Point, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Point, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Point)
					}
					yyv1[yyj1].CodecDecodeSelf(d)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Point, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
