// +build go1.6

// Code generated by codecgen - DO NOT EDIT.

package sql

import (
	"errors"
	codec1978 "github.com/ugorji/go/codec"
	pkg1_language "golang.org/x/text/language"
	"runtime"
	"strconv"
	"time"
)

const (
	// ----- content types ----
	codecSelferCcUTF88312 = 1
	codecSelferCcRAW8312  = 255
	// ----- value types used ----
	codecSelferValueTypeArray8312     = 10
	codecSelferValueTypeMap8312       = 9
	codecSelferValueTypeString8312    = 6
	codecSelferValueTypeInt8312       = 2
	codecSelferValueTypeUint8312      = 3
	codecSelferValueTypeFloat8312     = 4
	codecSelferValueTypeNil8312       = 1
	codecSelferBitsize8312            = uint8(32 << (^uint(0) >> 63))
	codecSelferDecContainerLenNil8312 = -2147483648
)

var (
	errCodecSelferOnlyMapOrArrayEncodeToStruct8312 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer8312 struct{}

func codecSelfer8312False() bool { return false }
func codecSelfer8312True() bool  { return true }

func init() {
	if codec1978.GenVersion != 20 {
		_, file, _, _ := runtime.Caller(0)
		ver := strconv.FormatInt(int64(codec1978.GenVersion), 10)
		panic(errors.New("codecgen version mismatch: current: 20, need " + ver + ". Re-generate file: " + file))
	}
	if false { // reference the types, but skip this branch at build/run time
		var _ pkg1_language.Tag
		var _ time.Duration
	}
}

func (x *Query) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Statements); yyxt4 != nil {
				z.EncExtension(x.Statements, yyxt4)
				x.Statements.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Statements\"")
			} else {
				r.EncodeString(`Statements`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Statements); yyxt5 != nil {
				z.EncExtension(x.Statements, yyxt5)
				x.Statements.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Query) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Query{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Query) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Statements":
			if yyxt5 := z.Extension(x.Statements); yyxt5 != nil {
				z.DecExtension(&x.Statements, yyxt5)
			} else {
				x.Statements.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Query) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Statements); yyxt8 != nil {
		z.DecExtension(&x.Statements, yyxt8)
	} else {
		x.Statements.CodecDecodeSelf(d)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *Query) IsCodecEmpty() bool {
	return !(len(x.Statements) != 0 && true)
}

func (x Statements) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encStatements((Statements)(x), e)
	} // end block: if x slice == nil
}

func (x *Statements) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decStatements((*Statements)(x), d)
}

func (x *UseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.NS))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.DB))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NS\"")
			} else {
				r.EncodeString(`NS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.NS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DB\"")
			} else {
				r.EncodeString(`DB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.DB))
			z.EncWriteMapEnd()
		}
	}
}

func (x *UseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = UseStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *UseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "NS":
			x.NS = (string)(string(r.DecodeStringAsBytes()))
		case "DB":
			x.DB = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.NS = (string)(string(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DB = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *UseStatement) IsCodecEmpty() bool {
	return !(x.NS != "" && x.DB != "" && true)
}

func (x *OptStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Name))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.What))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Name))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.What))
			z.EncWriteMapEnd()
		}
	}
}

func (x *OptStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = OptStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *OptStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			x.Name = (string)(string(r.DecodeStringAsBytes()))
		case "What":
			x.What = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *OptStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Name = (string)(string(r.DecodeStringAsBytes()))
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.What = (bool)(r.DecodeBool())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *OptStatement) IsCodecEmpty() bool {
	return !(x.Name != "" && bool(x.What) && true)
}

func (x *BeginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *BeginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = BeginStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *BeginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BeginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *BeginStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *CancelStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *CancelStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = CancelStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *CancelStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CancelStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *CancelStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *CommitStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *CommitStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = CommitStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *CommitStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CommitStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *CommitStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *InfoStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.EncExtension(x.Kind, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt6 := z.Extension(x.What); yyxt6 != nil {
					z.EncExtension(x.What, yyxt6)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt7 := z.Extension(x.Kind); yyxt7 != nil {
				z.EncExtension(x.Kind, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt8 := z.Extension(x.What); yyxt8 != nil {
					z.EncExtension(x.What, yyxt8)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *InfoStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = InfoStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *InfoStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.DecExtension(&x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				if yyxt7 := z.Extension(x.What); yyxt7 != nil {
					z.DecExtension(x.What, yyxt7)
				} else {
					x.What.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *InfoStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.Kind); yyxt10 != nil {
		z.DecExtension(&x.Kind, yyxt10)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		if yyxt12 := z.Extension(x.What); yyxt12 != nil {
			z.DecExtension(x.What, yyxt12)
		} else {
			x.What.CodecDecodeSelf(d)
		}
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *InfoStatement) IsCodecEmpty() bool {
	return !(x.Kind != 0 && true)
}

func (x *RunStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.Expr); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.Expr); yyxt8 != nil {
				z.EncExtension(x.Expr, yyxt8)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RunStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RunStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RunStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Expr":
			if yyxt6 := z.Extension(x.Expr); yyxt6 != nil {
				z.DecExtension(&x.Expr, yyxt6)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RunStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.Expr); yyxt10 != nil {
		z.DecExtension(&x.Expr, yyxt10)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *RunStatement) IsCodecEmpty() bool {
	return !(bool(x.RW) && x.Expr != nil && true)
}

func (x *LetStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
			} else {
				z.EncFallback(x.What)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
					z.EncExtension(x.Name, yyxt10)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.What); yyxt11 != nil {
				z.EncExtension(x.What, yyxt11)
			} else {
				z.EncFallback(x.What)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *LetStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = LetStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *LetStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt6 := z.Extension(x.Name); yyxt6 != nil {
					z.DecExtension(x.Name, yyxt6)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.DecExtension(&x.What, yyxt8)
			} else {
				z.DecFallback(&x.What, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *LetStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt12 := z.Extension(x.Name); yyxt12 != nil {
			z.DecExtension(x.Name, yyxt12)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.What); yyxt14 != nil {
		z.DecExtension(&x.What, yyxt14)
	} else {
		z.DecFallback(&x.What, true)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x *LetStatement) IsCodecEmpty() bool {
	return !(bool(x.RW) && x.What != nil && true)
}

func (x *LiveStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(9)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.ID))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.FB))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.NS))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.DB))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Diff))
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(x.Expr); yyxt17 != nil {
				z.EncExtension(x.Expr, yyxt17)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt18 := z.Extension(x.What); yyxt18 != nil {
				z.EncExtension(x.What, yyxt18)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt19 := z.Extension(x.Cond); yyxt19 != nil {
				z.EncExtension(x.Cond, yyxt19)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt20 := z.Extension(x.Fetch); yyxt20 != nil {
				z.EncExtension(x.Fetch, yyxt20)
				x.Fetch.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(9)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"ID\"")
			} else {
				r.EncodeString(`ID`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.ID))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"FB\"")
			} else {
				r.EncodeString(`FB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.FB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"NS\"")
			} else {
				r.EncodeString(`NS`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.NS))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"DB\"")
			} else {
				r.EncodeString(`DB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.DB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Diff\"")
			} else {
				r.EncodeString(`Diff`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Diff))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt26 := z.Extension(x.Expr); yyxt26 != nil {
				z.EncExtension(x.Expr, yyxt26)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt27 := z.Extension(x.What); yyxt27 != nil {
				z.EncExtension(x.What, yyxt27)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt28 := z.Extension(x.Cond); yyxt28 != nil {
				z.EncExtension(x.Cond, yyxt28)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Fetch\"")
			} else {
				r.EncodeString(`Fetch`)
			}
			z.EncWriteMapElemValue()
			if yyxt29 := z.Extension(x.Fetch); yyxt29 != nil {
				z.EncExtension(x.Fetch, yyxt29)
				x.Fetch.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *LiveStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = LiveStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *LiveStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "ID":
			x.ID = (string)(string(r.DecodeStringAsBytes()))
		case "FB":
			x.FB = (string)(string(r.DecodeStringAsBytes()))
		case "NS":
			x.NS = (string)(string(r.DecodeStringAsBytes()))
		case "DB":
			x.DB = (string)(string(r.DecodeStringAsBytes()))
		case "Diff":
			x.Diff = (bool)(r.DecodeBool())
		case "Expr":
			if yyxt10 := z.Extension(x.Expr); yyxt10 != nil {
				z.DecExtension(&x.Expr, yyxt10)
			} else {
				x.Expr.CodecDecodeSelf(d)
			}
		case "What":
			if yyxt12 := z.Extension(x.What); yyxt12 != nil {
				z.DecExtension(&x.What, yyxt12)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Cond":
			if yyxt14 := z.Extension(x.Cond); yyxt14 != nil {
				z.DecExtension(&x.Cond, yyxt14)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Fetch":
			if yyxt16 := z.Extension(x.Fetch); yyxt16 != nil {
				z.DecExtension(&x.Fetch, yyxt16)
			} else {
				x.Fetch.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *LiveStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.ID = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.FB = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.NS = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.DB = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Diff = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt24 := z.Extension(x.Expr); yyxt24 != nil {
		z.DecExtension(&x.Expr, yyxt24)
	} else {
		x.Expr.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt26 := z.Extension(x.What); yyxt26 != nil {
		z.DecExtension(&x.What, yyxt26)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt28 := z.Extension(x.Cond); yyxt28 != nil {
		z.DecExtension(&x.Cond, yyxt28)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(x.Fetch); yyxt30 != nil {
		z.DecExtension(&x.Fetch, yyxt30)
	} else {
		x.Fetch.CodecDecodeSelf(d)
	}
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = z.DecCheckBreak()
		}
		if yyb17 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj17-1, "")
	}
}

func (x *LiveStatement) IsCodecEmpty() bool {
	return !(x.ID != "" && x.FB != "" && x.NS != "" && x.DB != "" && bool(x.Diff) && len(x.Expr) != 0 && len(x.What) != 0 && x.Cond != nil && len(x.Fetch) != 0 && true)
}

func (x *KillStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.FB))
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"FB\"")
			} else {
				r.EncodeString(`FB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.FB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *KillStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = KillStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *KillStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "FB":
			x.FB = (string)(string(r.DecodeStringAsBytes()))
		case "What":
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.DecExtension(&x.What, yyxt6)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *KillStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.FB = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.What); yyxt10 != nil {
		z.DecExtension(&x.What, yyxt10)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *KillStatement) IsCodecEmpty() bool {
	return !(x.FB != "" && len(x.What) != 0 && true)
}

func (x *ReturnStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *ReturnStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = ReturnStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *ReturnStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "What":
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.DecExtension(&x.What, yyxt6)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ReturnStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.What); yyxt10 != nil {
		z.DecExtension(&x.What, yyxt10)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *ReturnStatement) IsCodecEmpty() bool {
	return !(bool(x.RW) && len(x.What) != 0 && true)
}

func (x *IfelseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Cond); yyxt8 != nil {
				z.EncExtension(x.Cond, yyxt8)
				x.Cond.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Then); yyxt9 != nil {
				z.EncExtension(x.Then, yyxt9)
				x.Then.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Else); yyxt10 != nil {
				z.EncExtension(x.Else, yyxt10)
			} else {
				z.EncFallback(x.Else)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.Cond); yyxt12 != nil {
				z.EncExtension(x.Cond, yyxt12)
				x.Cond.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Then\"")
			} else {
				r.EncodeString(`Then`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Then); yyxt13 != nil {
				z.EncExtension(x.Then, yyxt13)
				x.Then.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Else\"")
			} else {
				r.EncodeString(`Else`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Else); yyxt14 != nil {
				z.EncExtension(x.Else, yyxt14)
			} else {
				z.EncFallback(x.Else)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *IfelseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = IfelseStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *IfelseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Cond":
			if yyxt6 := z.Extension(x.Cond); yyxt6 != nil {
				z.DecExtension(&x.Cond, yyxt6)
			} else {
				x.Cond.CodecDecodeSelf(d)
			}
		case "Then":
			if yyxt8 := z.Extension(x.Then); yyxt8 != nil {
				z.DecExtension(&x.Then, yyxt8)
			} else {
				x.Then.CodecDecodeSelf(d)
			}
		case "Else":
			if yyxt10 := z.Extension(x.Else); yyxt10 != nil {
				z.DecExtension(&x.Else, yyxt10)
			} else {
				z.DecFallback(&x.Else, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *IfelseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj11 int
	var yyb11 bool
	var yyhl11 bool = l >= 0
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Cond); yyxt14 != nil {
		z.DecExtension(&x.Cond, yyxt14)
	} else {
		x.Cond.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Then); yyxt16 != nil {
		z.DecExtension(&x.Then, yyxt16)
	} else {
		x.Then.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Else); yyxt18 != nil {
		z.DecExtension(&x.Else, yyxt18)
	} else {
		z.DecFallback(&x.Else, true)
	}
	for {
		yyj11++
		if yyhl11 {
			yyb11 = yyj11 > l
		} else {
			yyb11 = z.DecCheckBreak()
		}
		if yyb11 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj11-1, "")
	}
}

func (x *IfelseStatement) IsCodecEmpty() bool {
	return !(bool(x.RW) && len(x.Cond) != 0 && len(x.Then) != 0 && x.Else != nil && true)
}

func (x *SelectStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(12)
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.RW))
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(x.Expr); yyxt16 != nil {
				z.EncExtension(x.Expr, yyxt16)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(x.What); yyxt17 != nil {
				z.EncExtension(x.What, yyxt17)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt18 := z.Extension(x.Cond); yyxt18 != nil {
				z.EncExtension(x.Cond, yyxt18)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt19 := z.Extension(x.Split); yyxt19 != nil {
				z.EncExtension(x.Split, yyxt19)
				x.Split.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt20 := z.Extension(x.Group); yyxt20 != nil {
				z.EncExtension(x.Group, yyxt20)
				x.Group.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt21 := z.Extension(x.Order); yyxt21 != nil {
				z.EncExtension(x.Order, yyxt21)
				x.Order.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt22 := z.Extension(x.Limit); yyxt22 != nil {
				z.EncExtension(x.Limit, yyxt22)
			} else {
				z.EncFallback(x.Limit)
			}
			z.EncWriteArrayElem()
			if yyxt23 := z.Extension(x.Start); yyxt23 != nil {
				z.EncExtension(x.Start, yyxt23)
			} else {
				z.EncFallback(x.Start)
			}
			z.EncWriteArrayElem()
			if yyxt24 := z.Extension(x.Fetch); yyxt24 != nil {
				z.EncExtension(x.Fetch, yyxt24)
				x.Fetch.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt25 := z.Extension(x.Version); yyxt25 != nil {
				z.EncExtension(x.Version, yyxt25)
			} else {
				z.EncFallback(x.Version)
			}
			z.EncWriteArrayElem()
			if yyxt26 := z.Extension(x.Timeout); yyxt26 != nil {
				z.EncExtension(x.Timeout, yyxt26)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(12)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RW\"")
			} else {
				r.EncodeString(`RW`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.RW))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt28 := z.Extension(x.Expr); yyxt28 != nil {
				z.EncExtension(x.Expr, yyxt28)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt29 := z.Extension(x.What); yyxt29 != nil {
				z.EncExtension(x.What, yyxt29)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt30 := z.Extension(x.Cond); yyxt30 != nil {
				z.EncExtension(x.Cond, yyxt30)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Split\"")
			} else {
				r.EncodeString(`Split`)
			}
			z.EncWriteMapElemValue()
			if yyxt31 := z.Extension(x.Split); yyxt31 != nil {
				z.EncExtension(x.Split, yyxt31)
				x.Split.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Group\"")
			} else {
				r.EncodeString(`Group`)
			}
			z.EncWriteMapElemValue()
			if yyxt32 := z.Extension(x.Group); yyxt32 != nil {
				z.EncExtension(x.Group, yyxt32)
				x.Group.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Order\"")
			} else {
				r.EncodeString(`Order`)
			}
			z.EncWriteMapElemValue()
			if yyxt33 := z.Extension(x.Order); yyxt33 != nil {
				z.EncExtension(x.Order, yyxt33)
				x.Order.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Limit\"")
			} else {
				r.EncodeString(`Limit`)
			}
			z.EncWriteMapElemValue()
			if yyxt34 := z.Extension(x.Limit); yyxt34 != nil {
				z.EncExtension(x.Limit, yyxt34)
			} else {
				z.EncFallback(x.Limit)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Start\"")
			} else {
				r.EncodeString(`Start`)
			}
			z.EncWriteMapElemValue()
			if yyxt35 := z.Extension(x.Start); yyxt35 != nil {
				z.EncExtension(x.Start, yyxt35)
			} else {
				z.EncFallback(x.Start)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Fetch\"")
			} else {
				r.EncodeString(`Fetch`)
			}
			z.EncWriteMapElemValue()
			if yyxt36 := z.Extension(x.Fetch); yyxt36 != nil {
				z.EncExtension(x.Fetch, yyxt36)
				x.Fetch.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Version\"")
			} else {
				r.EncodeString(`Version`)
			}
			z.EncWriteMapElemValue()
			if yyxt37 := z.Extension(x.Version); yyxt37 != nil {
				z.EncExtension(x.Version, yyxt37)
			} else {
				z.EncFallback(x.Version)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt38 := z.Extension(x.Timeout); yyxt38 != nil {
				z.EncExtension(x.Timeout, yyxt38)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SelectStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = SelectStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *SelectStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "RW":
			x.RW = (bool)(r.DecodeBool())
		case "Expr":
			if yyxt6 := z.Extension(x.Expr); yyxt6 != nil {
				z.DecExtension(&x.Expr, yyxt6)
			} else {
				x.Expr.CodecDecodeSelf(d)
			}
		case "What":
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.DecExtension(&x.What, yyxt8)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Cond":
			if yyxt10 := z.Extension(x.Cond); yyxt10 != nil {
				z.DecExtension(&x.Cond, yyxt10)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Split":
			if yyxt12 := z.Extension(x.Split); yyxt12 != nil {
				z.DecExtension(&x.Split, yyxt12)
			} else {
				x.Split.CodecDecodeSelf(d)
			}
		case "Group":
			if yyxt14 := z.Extension(x.Group); yyxt14 != nil {
				z.DecExtension(&x.Group, yyxt14)
			} else {
				x.Group.CodecDecodeSelf(d)
			}
		case "Order":
			if yyxt16 := z.Extension(x.Order); yyxt16 != nil {
				z.DecExtension(&x.Order, yyxt16)
			} else {
				x.Order.CodecDecodeSelf(d)
			}
		case "Limit":
			if yyxt18 := z.Extension(x.Limit); yyxt18 != nil {
				z.DecExtension(&x.Limit, yyxt18)
			} else {
				z.DecFallback(&x.Limit, true)
			}
		case "Start":
			if yyxt20 := z.Extension(x.Start); yyxt20 != nil {
				z.DecExtension(&x.Start, yyxt20)
			} else {
				z.DecFallback(&x.Start, true)
			}
		case "Fetch":
			if yyxt22 := z.Extension(x.Fetch); yyxt22 != nil {
				z.DecExtension(&x.Fetch, yyxt22)
			} else {
				x.Fetch.CodecDecodeSelf(d)
			}
		case "Version":
			if yyxt24 := z.Extension(x.Version); yyxt24 != nil {
				z.DecExtension(&x.Version, yyxt24)
			} else {
				z.DecFallback(&x.Version, true)
			}
		case "Timeout":
			if yyxt26 := z.Extension(x.Timeout); yyxt26 != nil {
				z.DecExtension(&x.Timeout, yyxt26)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SelectStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj27 int
	var yyb27 bool
	var yyhl27 bool = l >= 0
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RW = (bool)(r.DecodeBool())
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(x.Expr); yyxt30 != nil {
		z.DecExtension(&x.Expr, yyxt30)
	} else {
		x.Expr.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt32 := z.Extension(x.What); yyxt32 != nil {
		z.DecExtension(&x.What, yyxt32)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt34 := z.Extension(x.Cond); yyxt34 != nil {
		z.DecExtension(&x.Cond, yyxt34)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt36 := z.Extension(x.Split); yyxt36 != nil {
		z.DecExtension(&x.Split, yyxt36)
	} else {
		x.Split.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt38 := z.Extension(x.Group); yyxt38 != nil {
		z.DecExtension(&x.Group, yyxt38)
	} else {
		x.Group.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt40 := z.Extension(x.Order); yyxt40 != nil {
		z.DecExtension(&x.Order, yyxt40)
	} else {
		x.Order.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt42 := z.Extension(x.Limit); yyxt42 != nil {
		z.DecExtension(&x.Limit, yyxt42)
	} else {
		z.DecFallback(&x.Limit, true)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt44 := z.Extension(x.Start); yyxt44 != nil {
		z.DecExtension(&x.Start, yyxt44)
	} else {
		z.DecFallback(&x.Start, true)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt46 := z.Extension(x.Fetch); yyxt46 != nil {
		z.DecExtension(&x.Fetch, yyxt46)
	} else {
		x.Fetch.CodecDecodeSelf(d)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt48 := z.Extension(x.Version); yyxt48 != nil {
		z.DecExtension(&x.Version, yyxt48)
	} else {
		z.DecFallback(&x.Version, true)
	}
	yyj27++
	if yyhl27 {
		yyb27 = yyj27 > l
	} else {
		yyb27 = z.DecCheckBreak()
	}
	if yyb27 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt50 := z.Extension(x.Timeout); yyxt50 != nil {
		z.DecExtension(&x.Timeout, yyxt50)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj27++
		if yyhl27 {
			yyb27 = yyj27 > l
		} else {
			yyb27 = z.DecCheckBreak()
		}
		if yyb27 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj27-1, "")
	}
}

func (x *SelectStatement) IsCodecEmpty() bool {
	return !(bool(x.RW) && len(x.Expr) != 0 && len(x.What) != 0 && x.Cond != nil && len(x.Split) != 0 && len(x.Group) != 0 && len(x.Order) != 0 && x.Limit != nil && x.Start != nil && len(x.Fetch) != 0 && x.Version != nil && x.Timeout != 0 && true)
}

func (x *CreateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.EncExtension(x.What, yyxt7)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Data); yyxt8 != nil {
				z.EncExtension(x.Data, yyxt8)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.EncExtension(x.Echo, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Timeout); yyxt10 != nil {
				z.EncExtension(x.Timeout, yyxt10)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.What); yyxt11 != nil {
				z.EncExtension(x.What, yyxt11)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.Data); yyxt12 != nil {
				z.EncExtension(x.Data, yyxt12)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Echo); yyxt13 != nil {
				z.EncExtension(x.Echo, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Timeout); yyxt14 != nil {
				z.EncExtension(x.Timeout, yyxt14)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *CreateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = CreateStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *CreateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.DecExtension(&x.What, yyxt5)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Data":
			if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
				z.DecExtension(&x.Data, yyxt7)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Echo":
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.DecExtension(&x.Echo, yyxt9)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt11 := z.Extension(x.Timeout); yyxt11 != nil {
				z.DecExtension(&x.Timeout, yyxt11)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *CreateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.What); yyxt14 != nil {
		z.DecExtension(&x.What, yyxt14)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Data); yyxt16 != nil {
		z.DecExtension(&x.Data, yyxt16)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Echo); yyxt18 != nil {
		z.DecExtension(&x.Echo, yyxt18)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Timeout); yyxt20 != nil {
		z.DecExtension(&x.Timeout, yyxt20)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *CreateStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.Data != nil && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *UpdateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Data); yyxt9 != nil {
				z.EncExtension(x.Data, yyxt9)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Cond); yyxt10 != nil {
				z.EncExtension(x.Cond, yyxt10)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(x.Echo); yyxt11 != nil {
				z.EncExtension(x.Echo, yyxt11)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(x.Timeout); yyxt12 != nil {
				z.EncExtension(x.Timeout, yyxt12)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.What); yyxt13 != nil {
				z.EncExtension(x.What, yyxt13)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Data); yyxt14 != nil {
				z.EncExtension(x.Data, yyxt14)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt15 := z.Extension(x.Cond); yyxt15 != nil {
				z.EncExtension(x.Cond, yyxt15)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt16 := z.Extension(x.Echo); yyxt16 != nil {
				z.EncExtension(x.Echo, yyxt16)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt17 := z.Extension(x.Timeout); yyxt17 != nil {
				z.EncExtension(x.Timeout, yyxt17)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *UpdateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = UpdateStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *UpdateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.DecExtension(&x.What, yyxt5)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Data":
			if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
				z.DecExtension(&x.Data, yyxt7)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Cond":
			if yyxt9 := z.Extension(x.Cond); yyxt9 != nil {
				z.DecExtension(&x.Cond, yyxt9)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Echo":
			if yyxt11 := z.Extension(x.Echo); yyxt11 != nil {
				z.DecExtension(&x.Echo, yyxt11)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt13 := z.Extension(x.Timeout); yyxt13 != nil {
				z.DecExtension(&x.Timeout, yyxt13)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UpdateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.What); yyxt16 != nil {
		z.DecExtension(&x.What, yyxt16)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Data); yyxt18 != nil {
		z.DecExtension(&x.Data, yyxt18)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Cond); yyxt20 != nil {
		z.DecExtension(&x.Cond, yyxt20)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt22 := z.Extension(x.Echo); yyxt22 != nil {
		z.DecExtension(&x.Echo, yyxt22)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt24 := z.Extension(x.Timeout); yyxt24 != nil {
		z.DecExtension(&x.Timeout, yyxt24)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = z.DecCheckBreak()
		}
		if yyb14 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
}

func (x *UpdateStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.Data != nil && x.Cond != nil && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *DeleteStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.EncExtension(x.What, yyxt7)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Cond); yyxt8 != nil {
				z.EncExtension(x.Cond, yyxt8)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.EncExtension(x.Echo, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Timeout); yyxt10 != nil {
				z.EncExtension(x.Timeout, yyxt10)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.What); yyxt11 != nil {
				z.EncExtension(x.What, yyxt11)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.Cond); yyxt12 != nil {
				z.EncExtension(x.Cond, yyxt12)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Echo); yyxt13 != nil {
				z.EncExtension(x.Echo, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Timeout); yyxt14 != nil {
				z.EncExtension(x.Timeout, yyxt14)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DeleteStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DeleteStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DeleteStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.DecExtension(&x.What, yyxt5)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Cond":
			if yyxt7 := z.Extension(x.Cond); yyxt7 != nil {
				z.DecExtension(&x.Cond, yyxt7)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Echo":
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.DecExtension(&x.Echo, yyxt9)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt11 := z.Extension(x.Timeout); yyxt11 != nil {
				z.DecExtension(&x.Timeout, yyxt11)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DeleteStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.What); yyxt14 != nil {
		z.DecExtension(&x.What, yyxt14)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Cond); yyxt16 != nil {
		z.DecExtension(&x.Cond, yyxt16)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Echo); yyxt18 != nil {
		z.DecExtension(&x.Echo, yyxt18)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Timeout); yyxt20 != nil {
		z.DecExtension(&x.Timeout, yyxt20)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *DeleteStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.Cond != nil && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *RelateStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(7)
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Type); yyxt10 != nil {
				z.EncExtension(x.Type, yyxt10)
			} else {
				z.EncFallback(x.Type)
			}
			z.EncWriteArrayElem()
			if yyxt11 := z.Extension(x.From); yyxt11 != nil {
				z.EncExtension(x.From, yyxt11)
				x.From.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(x.With); yyxt12 != nil {
				z.EncExtension(x.With, yyxt12)
				x.With.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt13 := z.Extension(x.Data); yyxt13 != nil {
				z.EncExtension(x.Data, yyxt13)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteArrayElem()
			if yyxt15 := z.Extension(x.Echo); yyxt15 != nil {
				z.EncExtension(x.Echo, yyxt15)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(x.Timeout); yyxt16 != nil {
				z.EncExtension(x.Timeout, yyxt16)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(7)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			if yyxt17 := z.Extension(x.Type); yyxt17 != nil {
				z.EncExtension(x.Type, yyxt17)
			} else {
				z.EncFallback(x.Type)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"From\"")
			} else {
				r.EncodeString(`From`)
			}
			z.EncWriteMapElemValue()
			if yyxt18 := z.Extension(x.From); yyxt18 != nil {
				z.EncExtension(x.From, yyxt18)
				x.From.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"With\"")
			} else {
				r.EncodeString(`With`)
			}
			z.EncWriteMapElemValue()
			if yyxt19 := z.Extension(x.With); yyxt19 != nil {
				z.EncExtension(x.With, yyxt19)
				x.With.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt20 := z.Extension(x.Data); yyxt20 != nil {
				z.EncExtension(x.Data, yyxt20)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Uniq\"")
			} else {
				r.EncodeString(`Uniq`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt22 := z.Extension(x.Echo); yyxt22 != nil {
				z.EncExtension(x.Echo, yyxt22)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt23 := z.Extension(x.Timeout); yyxt23 != nil {
				z.EncExtension(x.Timeout, yyxt23)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RelateStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RelateStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RelateStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Type":
			if yyxt5 := z.Extension(x.Type); yyxt5 != nil {
				z.DecExtension(&x.Type, yyxt5)
			} else {
				z.DecFallback(&x.Type, true)
			}
		case "From":
			if yyxt7 := z.Extension(x.From); yyxt7 != nil {
				z.DecExtension(&x.From, yyxt7)
			} else {
				x.From.CodecDecodeSelf(d)
			}
		case "With":
			if yyxt9 := z.Extension(x.With); yyxt9 != nil {
				z.DecExtension(&x.With, yyxt9)
			} else {
				x.With.CodecDecodeSelf(d)
			}
		case "Data":
			if yyxt11 := z.Extension(x.Data); yyxt11 != nil {
				z.DecExtension(&x.Data, yyxt11)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Uniq":
			x.Uniq = (bool)(r.DecodeBool())
		case "Echo":
			if yyxt14 := z.Extension(x.Echo); yyxt14 != nil {
				z.DecExtension(&x.Echo, yyxt14)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt16 := z.Extension(x.Timeout); yyxt16 != nil {
				z.DecExtension(&x.Timeout, yyxt16)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RelateStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt19 := z.Extension(x.Type); yyxt19 != nil {
		z.DecExtension(&x.Type, yyxt19)
	} else {
		z.DecFallback(&x.Type, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt21 := z.Extension(x.From); yyxt21 != nil {
		z.DecExtension(&x.From, yyxt21)
	} else {
		x.From.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt23 := z.Extension(x.With); yyxt23 != nil {
		z.DecExtension(&x.With, yyxt23)
	} else {
		x.With.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt25 := z.Extension(x.Data); yyxt25 != nil {
		z.DecExtension(&x.Data, yyxt25)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Uniq = (bool)(r.DecodeBool())
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt28 := z.Extension(x.Echo); yyxt28 != nil {
		z.DecExtension(&x.Echo, yyxt28)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(x.Timeout); yyxt30 != nil {
		z.DecExtension(&x.Timeout, yyxt30)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = z.DecCheckBreak()
		}
		if yyb17 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj17-1, "")
	}
}

func (x *RelateStatement) IsCodecEmpty() bool {
	return !(x.Type != nil && len(x.From) != 0 && len(x.With) != 0 && x.Data != nil && bool(x.Uniq) && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *InsertStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Into == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
				z.EncExtension(x.Data, yyxt7)
			} else {
				z.EncFallback(x.Data)
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt8 := z.Extension(x.Into); yyxt8 != nil {
					z.EncExtension(x.Into, yyxt8)
					x.Into.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.EncExtension(x.Echo, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Timeout); yyxt10 != nil {
				z.EncExtension(x.Timeout, yyxt10)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.Data); yyxt11 != nil {
				z.EncExtension(x.Data, yyxt11)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Into\"")
			} else {
				r.EncodeString(`Into`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt12 := z.Extension(x.Into); yyxt12 != nil {
					z.EncExtension(x.Into, yyxt12)
					x.Into.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Echo); yyxt13 != nil {
				z.EncExtension(x.Echo, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Timeout); yyxt14 != nil {
				z.EncExtension(x.Timeout, yyxt14)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *InsertStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = InsertStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *InsertStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.DecExtension(&x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Into":
			if r.TryNil() {
				if x.Into != nil { // remove the if-true
					x.Into = nil
				}
			} else {
				if x.Into == nil {
					x.Into = new(Table)
				}
				if yyxt7 := z.Extension(x.Into); yyxt7 != nil {
					z.DecExtension(x.Into, yyxt7)
				} else {
					x.Into.CodecDecodeSelf(d)
				}
			}
		case "Echo":
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.DecExtension(&x.Echo, yyxt9)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt11 := z.Extension(x.Timeout); yyxt11 != nil {
				z.DecExtension(&x.Timeout, yyxt11)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *InsertStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Data); yyxt14 != nil {
		z.DecExtension(&x.Data, yyxt14)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Into != nil { // remove the if-true
			x.Into = nil
		}
	} else {
		if x.Into == nil {
			x.Into = new(Table)
		}
		if yyxt16 := z.Extension(x.Into); yyxt16 != nil {
			z.DecExtension(x.Into, yyxt16)
		} else {
			x.Into.CodecDecodeSelf(d)
		}
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Echo); yyxt18 != nil {
		z.DecExtension(&x.Echo, yyxt18)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Timeout); yyxt20 != nil {
		z.DecExtension(&x.Timeout, yyxt20)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *InsertStatement) IsCodecEmpty() bool {
	return !(x.Data != nil && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *UpsertStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Into == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Data); yyxt7 != nil {
				z.EncExtension(x.Data, yyxt7)
			} else {
				z.EncFallback(x.Data)
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt8 := z.Extension(x.Into); yyxt8 != nil {
					z.EncExtension(x.Into, yyxt8)
					x.Into.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.EncExtension(x.Echo, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Timeout); yyxt10 != nil {
				z.EncExtension(x.Timeout, yyxt10)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.Data); yyxt11 != nil {
				z.EncExtension(x.Data, yyxt11)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Into\"")
			} else {
				r.EncodeString(`Into`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt12 := z.Extension(x.Into); yyxt12 != nil {
					z.EncExtension(x.Into, yyxt12)
					x.Into.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Echo\"")
			} else {
				r.EncodeString(`Echo`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Echo); yyxt13 != nil {
				z.EncExtension(x.Echo, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Echo)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Echo)
			} else {
				r.EncodeInt(int64(x.Echo))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Timeout\"")
			} else {
				r.EncodeString(`Timeout`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Timeout); yyxt14 != nil {
				z.EncExtension(x.Timeout, yyxt14)
			} else {
				r.EncodeInt(int64(x.Timeout))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *UpsertStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = UpsertStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *UpsertStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.DecExtension(&x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		case "Into":
			if r.TryNil() {
				if x.Into != nil { // remove the if-true
					x.Into = nil
				}
			} else {
				if x.Into == nil {
					x.Into = new(Table)
				}
				if yyxt7 := z.Extension(x.Into); yyxt7 != nil {
					z.DecExtension(x.Into, yyxt7)
				} else {
					x.Into.CodecDecodeSelf(d)
				}
			}
		case "Echo":
			if yyxt9 := z.Extension(x.Echo); yyxt9 != nil {
				z.DecExtension(&x.Echo, yyxt9)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Echo)
			} else {
				x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Timeout":
			if yyxt11 := z.Extension(x.Timeout); yyxt11 != nil {
				z.DecExtension(&x.Timeout, yyxt11)
			} else {
				x.Timeout = (time.Duration)(r.DecodeInt64())
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *UpsertStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Data); yyxt14 != nil {
		z.DecExtension(&x.Data, yyxt14)
	} else {
		z.DecFallback(&x.Data, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Into != nil { // remove the if-true
			x.Into = nil
		}
	} else {
		if x.Into == nil {
			x.Into = new(Table)
		}
		if yyxt16 := z.Extension(x.Into); yyxt16 != nil {
			z.DecExtension(x.Into, yyxt16)
		} else {
			x.Into.CodecDecodeSelf(d)
		}
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Echo); yyxt18 != nil {
		z.DecExtension(&x.Echo, yyxt18)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Echo)
	} else {
		x.Echo = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Timeout); yyxt20 != nil {
		z.DecExtension(&x.Timeout, yyxt20)
	} else {
		x.Timeout = (time.Duration)(r.DecodeInt64())
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *UpsertStatement) IsCodecEmpty() bool {
	return !(x.Data != nil && x.Echo != 0 && x.Timeout != 0 && true)
}

func (x *DefineNamespaceStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt4 := z.Extension(x.Name); yyxt4 != nil {
					z.EncExtension(x.Name, yyxt4)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineNamespaceStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineNamespaceStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineNamespaceStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineNamespaceStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt8 := z.Extension(x.Name); yyxt8 != nil {
			z.DecExtension(x.Name, yyxt8)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DefineNamespaceStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *RemoveNamespaceStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt4 := z.Extension(x.Name); yyxt4 != nil {
					z.EncExtension(x.Name, yyxt4)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveNamespaceStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveNamespaceStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveNamespaceStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveNamespaceStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt8 := z.Extension(x.Name); yyxt8 != nil {
			z.DecExtension(x.Name, yyxt8)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *RemoveNamespaceStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *DefineDatabaseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt4 := z.Extension(x.Name); yyxt4 != nil {
					z.EncExtension(x.Name, yyxt4)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineDatabaseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineDatabaseStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineDatabaseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineDatabaseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt8 := z.Extension(x.Name); yyxt8 != nil {
			z.DecExtension(x.Name, yyxt8)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DefineDatabaseStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *RemoveDatabaseStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt4 := z.Extension(x.Name); yyxt4 != nil {
					z.EncExtension(x.Name, yyxt4)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveDatabaseStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveDatabaseStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveDatabaseStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveDatabaseStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt8 := z.Extension(x.Name); yyxt8 != nil {
			z.DecExtension(x.Name, yyxt8)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *RemoveDatabaseStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *DefineLoginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.User == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Kind); yyxt8 != nil {
				z.EncExtension(x.Kind, yyxt8)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt9 := z.Extension(x.User); yyxt9 != nil {
					z.EncExtension(x.User, yyxt9)
					x.User.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if x.Pass == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Pass))
			} // end block: if x.Pass slice == nil
			z.EncWriteArrayElem()
			if x.Hash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Hash))
			} // end block: if x.Hash slice == nil
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Kind); yyxt13 != nil {
				z.EncExtension(x.Kind, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"User\"")
			} else {
				r.EncodeString(`User`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt14 := z.Extension(x.User); yyxt14 != nil {
					z.EncExtension(x.User, yyxt14)
					x.User.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Pass\"")
			} else {
				r.EncodeString(`Pass`)
			}
			z.EncWriteMapElemValue()
			if x.Pass == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Pass))
			} // end block: if x.Pass slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Hash\"")
			} else {
				r.EncodeString(`Hash`)
			}
			z.EncWriteMapElemValue()
			if x.Hash == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Hash))
			} // end block: if x.Hash slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineLoginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineLoginStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineLoginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.DecExtension(&x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "User":
			if r.TryNil() {
				if x.User != nil { // remove the if-true
					x.User = nil
				}
			} else {
				if x.User == nil {
					x.User = new(Ident)
				}
				if yyxt7 := z.Extension(x.User); yyxt7 != nil {
					z.DecExtension(x.User, yyxt7)
				} else {
					x.User.CodecDecodeSelf(d)
				}
			}
		case "Pass":
			x.Pass = r.DecodeBytes(([]byte)(x.Pass), false)
		case "Hash":
			x.Hash = r.DecodeBytes(([]byte)(x.Hash), false)
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineLoginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj14 int
	var yyb14 bool
	var yyhl14 bool = l >= 0
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Kind); yyxt16 != nil {
		z.DecExtension(&x.Kind, yyxt16)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.User != nil { // remove the if-true
			x.User = nil
		}
	} else {
		if x.User == nil {
			x.User = new(Ident)
		}
		if yyxt18 := z.Extension(x.User); yyxt18 != nil {
			z.DecExtension(x.User, yyxt18)
		} else {
			x.User.CodecDecodeSelf(d)
		}
	}
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Pass = r.DecodeBytes(([]byte)(x.Pass), false)
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Hash = r.DecodeBytes(([]byte)(x.Hash), false)
	yyj14++
	if yyhl14 {
		yyb14 = yyj14 > l
	} else {
		yyb14 = z.DecCheckBreak()
	}
	if yyb14 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	for {
		yyj14++
		if yyhl14 {
			yyb14 = yyj14 > l
		} else {
			yyb14 = z.DecCheckBreak()
		}
		if yyb14 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj14-1, "")
	}
}

func (x *DefineLoginStatement) IsCodecEmpty() bool {
	return !(x.Kind != 0 && len(x.Pass) != 0 && len(x.Hash) != 0 && len(x.Code) != 0 && true)
}

func (x *RemoveLoginStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.User == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.EncExtension(x.Kind, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt6 := z.Extension(x.User); yyxt6 != nil {
					z.EncExtension(x.User, yyxt6)
					x.User.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt7 := z.Extension(x.Kind); yyxt7 != nil {
				z.EncExtension(x.Kind, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"User\"")
			} else {
				r.EncodeString(`User`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt8 := z.Extension(x.User); yyxt8 != nil {
					z.EncExtension(x.User, yyxt8)
					x.User.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveLoginStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveLoginStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveLoginStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.DecExtension(&x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "User":
			if r.TryNil() {
				if x.User != nil { // remove the if-true
					x.User = nil
				}
			} else {
				if x.User == nil {
					x.User = new(Ident)
				}
				if yyxt7 := z.Extension(x.User); yyxt7 != nil {
					z.DecExtension(x.User, yyxt7)
				} else {
					x.User.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveLoginStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.Kind); yyxt10 != nil {
		z.DecExtension(&x.Kind, yyxt10)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.User != nil { // remove the if-true
			x.User = nil
		}
	} else {
		if x.User == nil {
			x.User = new(Ident)
		}
		if yyxt12 := z.Extension(x.User); yyxt12 != nil {
			z.DecExtension(x.User, yyxt12)
		} else {
			x.User.CodecDecodeSelf(d)
		}
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *RemoveLoginStatement) IsCodecEmpty() bool {
	return !(x.Kind != 0 && true)
}

func (x *DefineTokenStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		var yyn5 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(5)
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Kind); yyxt8 != nil {
				z.EncExtension(x.Kind, yyxt8)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt9 := z.Extension(x.Name); yyxt9 != nil {
					z.EncExtension(x.Name, yyxt9)
					x.Name.CodecEncodeSelf(e)
				}
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt10 := z.Extension(x.What); yyxt10 != nil {
					z.EncExtension(x.What, yyxt10)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Type))
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(5)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Kind); yyxt13 != nil {
				z.EncExtension(x.Kind, yyxt13)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt14 := z.Extension(x.Name); yyxt14 != nil {
					z.EncExtension(x.Name, yyxt14)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				if yyxt15 := z.Extension(x.What); yyxt15 != nil {
					z.EncExtension(x.What, yyxt15)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Type))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineTokenStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineTokenStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineTokenStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.DecExtension(&x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.DecExtension(x.Name, yyxt7)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				if yyxt9 := z.Extension(x.What); yyxt9 != nil {
					z.DecExtension(x.What, yyxt9)
				} else {
					x.What.CodecDecodeSelf(d)
				}
			}
		case "Type":
			x.Type = (string)(string(r.DecodeStringAsBytes()))
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineTokenStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj13 int
	var yyb13 bool
	var yyhl13 bool = l >= 0
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt15 := z.Extension(x.Kind); yyxt15 != nil {
		z.DecExtension(&x.Kind, yyxt15)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt17 := z.Extension(x.Name); yyxt17 != nil {
			z.DecExtension(x.Name, yyxt17)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		if yyxt19 := z.Extension(x.What); yyxt19 != nil {
			z.DecExtension(x.What, yyxt19)
		} else {
			x.What.CodecDecodeSelf(d)
		}
	}
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Type = (string)(string(r.DecodeStringAsBytes()))
	yyj13++
	if yyhl13 {
		yyb13 = yyj13 > l
	} else {
		yyb13 = z.DecCheckBreak()
	}
	if yyb13 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	for {
		yyj13++
		if yyhl13 {
			yyb13 = yyj13 > l
		} else {
			yyb13 = z.DecCheckBreak()
		}
		if yyb13 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj13-1, "")
	}
}

func (x *DefineTokenStatement) IsCodecEmpty() bool {
	return !(x.Kind != 0 && x.Type != "" && len(x.Code) != 0 && true)
}

func (x *RemoveTokenStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		var yyn5 bool = x.What == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.Kind); yyxt6 != nil {
				z.EncExtension(x.Kind, yyxt6)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			if yyn5 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt8 := z.Extension(x.What); yyxt8 != nil {
					z.EncExtension(x.What, yyxt8)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(x.Kind); yyxt9 != nil {
				z.EncExtension(x.Kind, yyxt9)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Kind)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Kind)
			} else {
				r.EncodeInt(int64(x.Kind))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
					z.EncExtension(x.Name, yyxt10)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyn5 {
				r.EncodeNil()
			} else {
				if yyxt11 := z.Extension(x.What); yyxt11 != nil {
					z.EncExtension(x.What, yyxt11)
					x.What.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveTokenStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveTokenStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveTokenStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Kind":
			if yyxt5 := z.Extension(x.Kind); yyxt5 != nil {
				z.DecExtension(&x.Kind, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Kind)
			} else {
				x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.DecExtension(x.Name, yyxt7)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if r.TryNil() {
				if x.What != nil { // remove the if-true
					x.What = nil
				}
			} else {
				if x.What == nil {
					x.What = new(Ident)
				}
				if yyxt9 := z.Extension(x.What); yyxt9 != nil {
					z.DecExtension(x.What, yyxt9)
				} else {
					x.What.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveTokenStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.Kind); yyxt12 != nil {
		z.DecExtension(&x.Kind, yyxt12)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Kind)
	} else {
		x.Kind = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt14 := z.Extension(x.Name); yyxt14 != nil {
			z.DecExtension(x.Name, yyxt14)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.What != nil { // remove the if-true
			x.What = nil
		}
	} else {
		if x.What == nil {
			x.What = new(Ident)
		}
		if yyxt16 := z.Extension(x.What); yyxt16 != nil {
			z.DecExtension(x.What, yyxt16)
		} else {
			x.What.CodecDecodeSelf(d)
		}
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *RemoveTokenStatement) IsCodecEmpty() bool {
	return !(x.Kind != 0 && true)
}

func (x *DefineScopeStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(8)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt11 := z.Extension(x.Name); yyxt11 != nil {
					z.EncExtension(x.Name, yyxt11)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(x.Time); yyxt12 != nil {
				z.EncExtension(x.Time, yyxt12)
			} else {
				r.EncodeInt(int64(x.Time))
			}
			z.EncWriteArrayElem()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteArrayElem()
			if yyxt14 := z.Extension(x.Signup); yyxt14 != nil {
				z.EncExtension(x.Signup, yyxt14)
			} else {
				z.EncFallback(x.Signup)
			}
			z.EncWriteArrayElem()
			if yyxt15 := z.Extension(x.Signin); yyxt15 != nil {
				z.EncExtension(x.Signin, yyxt15)
			} else {
				z.EncFallback(x.Signin)
			}
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(x.Connect); yyxt16 != nil {
				z.EncExtension(x.Connect, yyxt16)
			} else {
				z.EncFallback(x.Connect)
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(x.OnSignup); yyxt17 != nil {
				z.EncExtension(x.OnSignup, yyxt17)
			} else {
				z.EncFallback(x.OnSignup)
			}
			z.EncWriteArrayElem()
			if yyxt18 := z.Extension(x.OnSignin); yyxt18 != nil {
				z.EncExtension(x.OnSignin, yyxt18)
			} else {
				z.EncFallback(x.OnSignin)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(8)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt19 := z.Extension(x.Name); yyxt19 != nil {
					z.EncExtension(x.Name, yyxt19)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Time\"")
			} else {
				r.EncodeString(`Time`)
			}
			z.EncWriteMapElemValue()
			if yyxt20 := z.Extension(x.Time); yyxt20 != nil {
				z.EncExtension(x.Time, yyxt20)
			} else {
				r.EncodeInt(int64(x.Time))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Code\"")
			} else {
				r.EncodeString(`Code`)
			}
			z.EncWriteMapElemValue()
			if x.Code == nil {
				r.EncodeNil()
			} else {
				r.EncodeStringBytesRaw([]byte(x.Code))
			} // end block: if x.Code slice == nil
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Signup\"")
			} else {
				r.EncodeString(`Signup`)
			}
			z.EncWriteMapElemValue()
			if yyxt22 := z.Extension(x.Signup); yyxt22 != nil {
				z.EncExtension(x.Signup, yyxt22)
			} else {
				z.EncFallback(x.Signup)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Signin\"")
			} else {
				r.EncodeString(`Signin`)
			}
			z.EncWriteMapElemValue()
			if yyxt23 := z.Extension(x.Signin); yyxt23 != nil {
				z.EncExtension(x.Signin, yyxt23)
			} else {
				z.EncFallback(x.Signin)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Connect\"")
			} else {
				r.EncodeString(`Connect`)
			}
			z.EncWriteMapElemValue()
			if yyxt24 := z.Extension(x.Connect); yyxt24 != nil {
				z.EncExtension(x.Connect, yyxt24)
			} else {
				z.EncFallback(x.Connect)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"OnSignup\"")
			} else {
				r.EncodeString(`OnSignup`)
			}
			z.EncWriteMapElemValue()
			if yyxt25 := z.Extension(x.OnSignup); yyxt25 != nil {
				z.EncExtension(x.OnSignup, yyxt25)
			} else {
				z.EncFallback(x.OnSignup)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"OnSignin\"")
			} else {
				r.EncodeString(`OnSignin`)
			}
			z.EncWriteMapElemValue()
			if yyxt26 := z.Extension(x.OnSignin); yyxt26 != nil {
				z.EncExtension(x.OnSignin, yyxt26)
			} else {
				z.EncFallback(x.OnSignin)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineScopeStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineScopeStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineScopeStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "Time":
			if yyxt7 := z.Extension(x.Time); yyxt7 != nil {
				z.DecExtension(&x.Time, yyxt7)
			} else {
				x.Time = (time.Duration)(r.DecodeInt64())
			}
		case "Code":
			x.Code = r.DecodeBytes(([]byte)(x.Code), false)
		case "Signup":
			if yyxt11 := z.Extension(x.Signup); yyxt11 != nil {
				z.DecExtension(&x.Signup, yyxt11)
			} else {
				z.DecFallback(&x.Signup, true)
			}
		case "Signin":
			if yyxt13 := z.Extension(x.Signin); yyxt13 != nil {
				z.DecExtension(&x.Signin, yyxt13)
			} else {
				z.DecFallback(&x.Signin, true)
			}
		case "Connect":
			if yyxt15 := z.Extension(x.Connect); yyxt15 != nil {
				z.DecExtension(&x.Connect, yyxt15)
			} else {
				z.DecFallback(&x.Connect, true)
			}
		case "OnSignup":
			if yyxt17 := z.Extension(x.OnSignup); yyxt17 != nil {
				z.DecExtension(&x.OnSignup, yyxt17)
			} else {
				z.DecFallback(&x.OnSignup, true)
			}
		case "OnSignin":
			if yyxt19 := z.Extension(x.OnSignin); yyxt19 != nil {
				z.DecExtension(&x.OnSignin, yyxt19)
			} else {
				z.DecFallback(&x.OnSignin, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineScopeStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj20 int
	var yyb20 bool
	var yyhl20 bool = l >= 0
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt22 := z.Extension(x.Name); yyxt22 != nil {
			z.DecExtension(x.Name, yyxt22)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt24 := z.Extension(x.Time); yyxt24 != nil {
		z.DecExtension(&x.Time, yyxt24)
	} else {
		x.Time = (time.Duration)(r.DecodeInt64())
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Code = r.DecodeBytes(([]byte)(x.Code), false)
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt28 := z.Extension(x.Signup); yyxt28 != nil {
		z.DecExtension(&x.Signup, yyxt28)
	} else {
		z.DecFallback(&x.Signup, true)
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt30 := z.Extension(x.Signin); yyxt30 != nil {
		z.DecExtension(&x.Signin, yyxt30)
	} else {
		z.DecFallback(&x.Signin, true)
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt32 := z.Extension(x.Connect); yyxt32 != nil {
		z.DecExtension(&x.Connect, yyxt32)
	} else {
		z.DecFallback(&x.Connect, true)
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt34 := z.Extension(x.OnSignup); yyxt34 != nil {
		z.DecExtension(&x.OnSignup, yyxt34)
	} else {
		z.DecFallback(&x.OnSignup, true)
	}
	yyj20++
	if yyhl20 {
		yyb20 = yyj20 > l
	} else {
		yyb20 = z.DecCheckBreak()
	}
	if yyb20 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt36 := z.Extension(x.OnSignin); yyxt36 != nil {
		z.DecExtension(&x.OnSignin, yyxt36)
	} else {
		z.DecFallback(&x.OnSignin, true)
	}
	for {
		yyj20++
		if yyhl20 {
			yyb20 = yyj20 > l
		} else {
			yyb20 = z.DecCheckBreak()
		}
		if yyb20 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj20-1, "")
	}
}

func (x *DefineScopeStatement) IsCodecEmpty() bool {
	return !(x.Time != 0 && len(x.Code) != 0 && x.Signup != nil && x.Signin != nil && x.Connect != nil && x.OnSignup != nil && x.OnSignin != nil && true)
}

func (x *RemoveScopeStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt4 := z.Extension(x.Name); yyxt4 != nil {
					z.EncExtension(x.Name, yyxt4)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveScopeStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveScopeStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveScopeStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveScopeStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt8 := z.Extension(x.Name); yyxt8 != nil {
			z.DecExtension(x.Name, yyxt8)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *RemoveScopeStatement) IsCodecEmpty() bool {
	return !(true)
}

func (x *DefineTableStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(11)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt14 := z.Extension(x.Name); yyxt14 != nil {
					z.EncExtension(x.Name, yyxt14)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt15 := z.Extension(x.What); yyxt15 != nil {
				z.EncExtension(x.What, yyxt15)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Full))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Vers))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Drop))
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Lock))
			z.EncWriteArrayElem()
			if yyxt20 := z.Extension(x.Expr); yyxt20 != nil {
				z.EncExtension(x.Expr, yyxt20)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt21 := z.Extension(x.From); yyxt21 != nil {
				z.EncExtension(x.From, yyxt21)
				x.From.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt22 := z.Extension(x.Cond); yyxt22 != nil {
				z.EncExtension(x.Cond, yyxt22)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayElem()
			if yyxt23 := z.Extension(x.Group); yyxt23 != nil {
				z.EncExtension(x.Group, yyxt23)
				x.Group.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt24 := z.Extension(x.Perms); yyxt24 != nil {
				z.EncExtension(x.Perms, yyxt24)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(11)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt25 := z.Extension(x.Name); yyxt25 != nil {
					z.EncExtension(x.Name, yyxt25)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt26 := z.Extension(x.What); yyxt26 != nil {
				z.EncExtension(x.What, yyxt26)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Full\"")
			} else {
				r.EncodeString(`Full`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Full))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Vers\"")
			} else {
				r.EncodeString(`Vers`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Vers))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Drop\"")
			} else {
				r.EncodeString(`Drop`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Drop))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Lock\"")
			} else {
				r.EncodeString(`Lock`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Lock))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt31 := z.Extension(x.Expr); yyxt31 != nil {
				z.EncExtension(x.Expr, yyxt31)
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"From\"")
			} else {
				r.EncodeString(`From`)
			}
			z.EncWriteMapElemValue()
			if yyxt32 := z.Extension(x.From); yyxt32 != nil {
				z.EncExtension(x.From, yyxt32)
				x.From.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt33 := z.Extension(x.Cond); yyxt33 != nil {
				z.EncExtension(x.Cond, yyxt33)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Group\"")
			} else {
				r.EncodeString(`Group`)
			}
			z.EncWriteMapElemValue()
			if yyxt34 := z.Extension(x.Group); yyxt34 != nil {
				z.EncExtension(x.Group, yyxt34)
				x.Group.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Perms\"")
			} else {
				r.EncodeString(`Perms`)
			}
			z.EncWriteMapElemValue()
			if yyxt35 := z.Extension(x.Perms); yyxt35 != nil {
				z.EncExtension(x.Perms, yyxt35)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineTableStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineTableStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineTableStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Full":
			x.Full = (bool)(r.DecodeBool())
		case "Vers":
			x.Vers = (bool)(r.DecodeBool())
		case "Drop":
			x.Drop = (bool)(r.DecodeBool())
		case "Lock":
			x.Lock = (bool)(r.DecodeBool())
		case "Expr":
			if yyxt13 := z.Extension(x.Expr); yyxt13 != nil {
				z.DecExtension(&x.Expr, yyxt13)
			} else {
				x.Expr.CodecDecodeSelf(d)
			}
		case "From":
			if yyxt15 := z.Extension(x.From); yyxt15 != nil {
				z.DecExtension(&x.From, yyxt15)
			} else {
				x.From.CodecDecodeSelf(d)
			}
		case "Cond":
			if yyxt17 := z.Extension(x.Cond); yyxt17 != nil {
				z.DecExtension(&x.Cond, yyxt17)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		case "Group":
			if yyxt19 := z.Extension(x.Group); yyxt19 != nil {
				z.DecExtension(&x.Group, yyxt19)
			} else {
				x.Group.CodecDecodeSelf(d)
			}
		case "Perms":
			if yyxt21 := z.Extension(x.Perms); yyxt21 != nil {
				z.DecExtension(&x.Perms, yyxt21)
			} else {
				z.DecFallback(&x.Perms, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineTableStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj22 int
	var yyb22 bool
	var yyhl22 bool = l >= 0
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt24 := z.Extension(x.Name); yyxt24 != nil {
			z.DecExtension(x.Name, yyxt24)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt26 := z.Extension(x.What); yyxt26 != nil {
		z.DecExtension(&x.What, yyxt26)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Full = (bool)(r.DecodeBool())
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Vers = (bool)(r.DecodeBool())
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Drop = (bool)(r.DecodeBool())
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Lock = (bool)(r.DecodeBool())
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt32 := z.Extension(x.Expr); yyxt32 != nil {
		z.DecExtension(&x.Expr, yyxt32)
	} else {
		x.Expr.CodecDecodeSelf(d)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt34 := z.Extension(x.From); yyxt34 != nil {
		z.DecExtension(&x.From, yyxt34)
	} else {
		x.From.CodecDecodeSelf(d)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt36 := z.Extension(x.Cond); yyxt36 != nil {
		z.DecExtension(&x.Cond, yyxt36)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt38 := z.Extension(x.Group); yyxt38 != nil {
		z.DecExtension(&x.Group, yyxt38)
	} else {
		x.Group.CodecDecodeSelf(d)
	}
	yyj22++
	if yyhl22 {
		yyb22 = yyj22 > l
	} else {
		yyb22 = z.DecCheckBreak()
	}
	if yyb22 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt40 := z.Extension(x.Perms); yyxt40 != nil {
		z.DecExtension(&x.Perms, yyxt40)
	} else {
		z.DecFallback(&x.Perms, true)
	}
	for {
		yyj22++
		if yyhl22 {
			yyb22 = yyj22 > l
		} else {
			yyb22 = z.DecCheckBreak()
		}
		if yyb22 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj22-1, "")
	}
}

func (x *DefineTableStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && bool(x.Full) && bool(x.Vers) && bool(x.Drop) && bool(x.Lock) && len(x.Expr) != 0 && len(x.From) != 0 && x.Cond != nil && len(x.Group) != 0 && x.Perms != nil && true)
}

func (x *RemoveTableStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.What); yyxt4 != nil {
				z.EncExtension(x.What, yyxt4)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.EncExtension(x.What, yyxt5)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveTableStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveTableStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveTableStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.DecExtension(&x.What, yyxt5)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveTableStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.What); yyxt8 != nil {
		z.DecExtension(&x.What, yyxt8)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *RemoveTableStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && true)
}

func (x *DefineEventStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.When); yyxt9 != nil {
				z.EncExtension(x.When, yyxt9)
			} else {
				z.EncFallback(x.When)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Then); yyxt10 != nil {
				z.EncExtension(x.Then, yyxt10)
			} else {
				z.EncFallback(x.Then)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt11 := z.Extension(x.Name); yyxt11 != nil {
					z.EncExtension(x.Name, yyxt11)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.What); yyxt12 != nil {
				z.EncExtension(x.What, yyxt12)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"When\"")
			} else {
				r.EncodeString(`When`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.When); yyxt13 != nil {
				z.EncExtension(x.When, yyxt13)
			} else {
				z.EncFallback(x.When)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Then\"")
			} else {
				r.EncodeString(`Then`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Then); yyxt14 != nil {
				z.EncExtension(x.Then, yyxt14)
			} else {
				z.EncFallback(x.Then)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineEventStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineEventStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineEventStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "When":
			if yyxt9 := z.Extension(x.When); yyxt9 != nil {
				z.DecExtension(&x.When, yyxt9)
			} else {
				z.DecFallback(&x.When, true)
			}
		case "Then":
			if yyxt11 := z.Extension(x.Then); yyxt11 != nil {
				z.DecExtension(&x.Then, yyxt11)
			} else {
				z.DecFallback(&x.Then, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineEventStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt14 := z.Extension(x.Name); yyxt14 != nil {
			z.DecExtension(x.Name, yyxt14)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.What); yyxt16 != nil {
		z.DecExtension(&x.What, yyxt16)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.When); yyxt18 != nil {
		z.DecExtension(&x.When, yyxt18)
	} else {
		z.DecFallback(&x.When, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Then); yyxt20 != nil {
		z.DecExtension(&x.Then, yyxt20)
	} else {
		z.DecFallback(&x.Then, true)
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *DefineEventStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.When != nil && x.Then != nil && true)
}

func (x *RemoveEventStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveEventStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveEventStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveEventStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveEventStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
			z.DecExtension(x.Name, yyxt10)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.What); yyxt12 != nil {
		z.DecExtension(&x.What, yyxt12)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *RemoveEventStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && true)
}

func (x *DefineFieldStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(8)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt11 := z.Extension(x.Name); yyxt11 != nil {
					z.EncExtension(x.Name, yyxt11)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt12 := z.Extension(x.What); yyxt12 != nil {
				z.EncExtension(x.What, yyxt12)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt13 := z.Extension(x.Perms); yyxt13 != nil {
				z.EncExtension(x.Perms, yyxt13)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Type))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Kind))
			z.EncWriteArrayElem()
			if yyxt16 := z.Extension(x.Value); yyxt16 != nil {
				z.EncExtension(x.Value, yyxt16)
			} else {
				z.EncFallback(x.Value)
			}
			z.EncWriteArrayElem()
			if yyxt17 := z.Extension(x.Assert); yyxt17 != nil {
				z.EncExtension(x.Assert, yyxt17)
			} else {
				z.EncFallback(x.Assert)
			}
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.Priority))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(8)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt19 := z.Extension(x.Name); yyxt19 != nil {
					z.EncExtension(x.Name, yyxt19)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt20 := z.Extension(x.What); yyxt20 != nil {
				z.EncExtension(x.What, yyxt20)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Perms\"")
			} else {
				r.EncodeString(`Perms`)
			}
			z.EncWriteMapElemValue()
			if yyxt21 := z.Extension(x.Perms); yyxt21 != nil {
				z.EncExtension(x.Perms, yyxt21)
			} else {
				z.EncFallback(x.Perms)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Type\"")
			} else {
				r.EncodeString(`Type`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Type))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Kind\"")
			} else {
				r.EncodeString(`Kind`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Kind))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Value\"")
			} else {
				r.EncodeString(`Value`)
			}
			z.EncWriteMapElemValue()
			if yyxt24 := z.Extension(x.Value); yyxt24 != nil {
				z.EncExtension(x.Value, yyxt24)
			} else {
				z.EncFallback(x.Value)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Assert\"")
			} else {
				r.EncodeString(`Assert`)
			}
			z.EncWriteMapElemValue()
			if yyxt25 := z.Extension(x.Assert); yyxt25 != nil {
				z.EncExtension(x.Assert, yyxt25)
			} else {
				z.EncFallback(x.Assert)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Priority\"")
			} else {
				r.EncodeString(`Priority`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.Priority))
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineFieldStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineFieldStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineFieldStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Perms":
			if yyxt9 := z.Extension(x.Perms); yyxt9 != nil {
				z.DecExtension(&x.Perms, yyxt9)
			} else {
				z.DecFallback(&x.Perms, true)
			}
		case "Type":
			x.Type = (string)(string(r.DecodeStringAsBytes()))
		case "Kind":
			x.Kind = (string)(string(r.DecodeStringAsBytes()))
		case "Value":
			if yyxt13 := z.Extension(x.Value); yyxt13 != nil {
				z.DecExtension(&x.Value, yyxt13)
			} else {
				z.DecFallback(&x.Value, true)
			}
		case "Assert":
			if yyxt15 := z.Extension(x.Assert); yyxt15 != nil {
				z.DecExtension(&x.Assert, yyxt15)
			} else {
				z.DecFallback(&x.Assert, true)
			}
		case "Priority":
			x.Priority = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineFieldStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt19 := z.Extension(x.Name); yyxt19 != nil {
			z.DecExtension(x.Name, yyxt19)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt21 := z.Extension(x.What); yyxt21 != nil {
		z.DecExtension(&x.What, yyxt21)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt23 := z.Extension(x.Perms); yyxt23 != nil {
		z.DecExtension(&x.Perms, yyxt23)
	} else {
		z.DecFallback(&x.Perms, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Type = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Kind = (string)(string(r.DecodeStringAsBytes()))
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt27 := z.Extension(x.Value); yyxt27 != nil {
		z.DecExtension(&x.Value, yyxt27)
	} else {
		z.DecFallback(&x.Value, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt29 := z.Extension(x.Assert); yyxt29 != nil {
		z.DecExtension(&x.Assert, yyxt29)
	} else {
		z.DecFallback(&x.Assert, true)
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = z.DecCheckBreak()
	}
	if yyb17 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Priority = (float64)(r.DecodeFloat64())
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = z.DecCheckBreak()
		}
		if yyb17 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj17-1, "")
	}
}

func (x *DefineFieldStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.Perms != nil && x.Type != "" && x.Kind != "" && x.Value != nil && x.Assert != nil && x.Priority != 0 && true)
}

func (x *RemoveFieldStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveFieldStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveFieldStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveFieldStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveFieldStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
			z.DecExtension(x.Name, yyxt10)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.What); yyxt12 != nil {
		z.DecExtension(&x.What, yyxt12)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *RemoveFieldStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && true)
}

func (x *DefineIndexStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Cols); yyxt9 != nil {
				z.EncExtension(x.Cols, yyxt9)
				x.Cols.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt11 := z.Extension(x.Name); yyxt11 != nil {
					z.EncExtension(x.Name, yyxt11)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.What); yyxt12 != nil {
				z.EncExtension(x.What, yyxt12)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cols\"")
			} else {
				r.EncodeString(`Cols`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Cols); yyxt13 != nil {
				z.EncExtension(x.Cols, yyxt13)
				x.Cols.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Uniq\"")
			} else {
				r.EncodeString(`Uniq`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Uniq))
			z.EncWriteMapEnd()
		}
	}
}

func (x *DefineIndexStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DefineIndexStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DefineIndexStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Cols":
			if yyxt9 := z.Extension(x.Cols); yyxt9 != nil {
				z.DecExtension(&x.Cols, yyxt9)
			} else {
				x.Cols.CodecDecodeSelf(d)
			}
		case "Uniq":
			x.Uniq = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DefineIndexStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj11 int
	var yyb11 bool
	var yyhl11 bool = l >= 0
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt13 := z.Extension(x.Name); yyxt13 != nil {
			z.DecExtension(x.Name, yyxt13)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt15 := z.Extension(x.What); yyxt15 != nil {
		z.DecExtension(&x.What, yyxt15)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt17 := z.Extension(x.Cols); yyxt17 != nil {
		z.DecExtension(&x.Cols, yyxt17)
	} else {
		x.Cols.CodecDecodeSelf(d)
	}
	yyj11++
	if yyhl11 {
		yyb11 = yyj11 > l
	} else {
		yyb11 = z.DecCheckBreak()
	}
	if yyb11 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Uniq = (bool)(r.DecodeBool())
	for {
		yyj11++
		if yyhl11 {
			yyb11 = yyj11 > l
		} else {
			yyb11 = z.DecCheckBreak()
		}
		if yyb11 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj11-1, "")
	}
}

func (x *DefineIndexStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && len(x.Cols) != 0 && bool(x.Uniq) && true)
}

func (x *RemoveIndexStatement) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn3 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			if yyn3 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.EncExtension(x.Name, yyxt5)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn3 {
				r.EncodeNil()
			} else {
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt8 := z.Extension(x.What); yyxt8 != nil {
				z.EncExtension(x.What, yyxt8)
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *RemoveIndexStatement) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = RemoveIndexStatement{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *RemoveIndexStatement) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt5 := z.Extension(x.Name); yyxt5 != nil {
					z.DecExtension(x.Name, yyxt5)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "What":
			if yyxt7 := z.Extension(x.What); yyxt7 != nil {
				z.DecExtension(&x.What, yyxt7)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *RemoveIndexStatement) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
			z.DecExtension(x.Name, yyxt10)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.What); yyxt12 != nil {
		z.DecExtension(&x.What, yyxt12)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *RemoveIndexStatement) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && true)
}

func (x Exprs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encExprs((Exprs)(x), e)
	} // end block: if x slice == nil
}

func (x *Exprs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decExprs((*Exprs)(x), d)
}

func (x *All) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *All) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = All{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *All) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *All) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *All) IsCodecEmpty() bool {
	return !(true)
}

func (x *Any) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Any) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Any{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Any) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Any) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Any) IsCodecEmpty() bool {
	return !(true)
}

func (x *Null) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Null) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Null{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Null) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Null) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Null) IsCodecEmpty() bool {
	return !(true)
}

func (x *Void) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Void) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Void{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Void) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Void) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Void) IsCodecEmpty() bool {
	return !(true)
}

func (x *Empty) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(0)
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(0)
			z.EncWriteMapEnd()
		}
	}
}

func (x *Empty) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Empty{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Empty) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Empty) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj4 int
	var yyb4 bool
	var yyhl4 bool = l >= 0
	for {
		yyj4++
		if yyhl4 {
			yyb4 = yyj4 > l
		} else {
			yyb4 = z.DecCheckBreak()
		}
		if yyb4 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj4-1, "")
	}
}

func (x *Empty) IsCodecEmpty() bool {
	return !(true)
}

func (x *Field) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.Expr); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Field))
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Alias))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(x.Expr); yyxt9 != nil {
				z.EncExtension(x.Expr, yyxt9)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Field\"")
			} else {
				r.EncodeString(`Field`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Field))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Alias\"")
			} else {
				r.EncodeString(`Alias`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Alias))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Field) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Field{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Field) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		case "Field":
			x.Field = (string)(string(r.DecodeStringAsBytes()))
		case "Alias":
			x.Alias = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Field) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt10 := z.Extension(x.Expr); yyxt10 != nil {
		z.DecExtension(&x.Expr, yyxt10)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Field = (string)(string(r.DecodeStringAsBytes()))
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Alias = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *Field) IsCodecEmpty() bool {
	return !(x.Expr != nil && x.Field != "" && x.Alias != "" && true)
}

func (x Fields) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encFields((Fields)(x), e)
	} // end block: if x slice == nil
}

func (x *Fields) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decFields((*Fields)(x), d)
}

func (x *Group) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Expr); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Group) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Group{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Group) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Group) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Expr); yyxt8 != nil {
		z.DecExtension(&x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *Group) IsCodecEmpty() bool {
	return !(x.Expr != nil && true)
}

func (x Groups) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encGroups((Groups)(x), e)
	} // end block: if x slice == nil
}

func (x *Groups) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decGroups((*Groups)(x), d)
}

func (x *Order) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.Expr); yyxt6 != nil {
				z.EncExtension(x.Expr, yyxt6)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Dir))
			z.EncWriteArrayElem()
			yy8 := &x.Tag
			if yyxt9 := z.Extension(yy8); yyxt9 != nil {
				z.EncExtension(yy8, yyxt9)
			} else if !z.EncBinary() {
				z.EncTextMarshal(*yy8)
			} else {
				z.EncFallback(yy8)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(x.Expr); yyxt10 != nil {
				z.EncExtension(x.Expr, yyxt10)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Dir\"")
			} else {
				r.EncodeString(`Dir`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Dir))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Tag\"")
			} else {
				r.EncodeString(`Tag`)
			}
			z.EncWriteMapElemValue()
			yy12 := &x.Tag
			if yyxt13 := z.Extension(yy12); yyxt13 != nil {
				z.EncExtension(yy12, yyxt13)
			} else if !z.EncBinary() {
				z.EncTextMarshal(*yy12)
			} else {
				z.EncFallback(yy12)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Order) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Order{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Order) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		case "Dir":
			x.Dir = (bool)(r.DecodeBool())
		case "Tag":
			if yyxt8 := z.Extension(x.Tag); yyxt8 != nil {
				z.DecExtension(&x.Tag, yyxt8)
			} else if !z.DecBinary() {
				z.DecTextUnmarshal(&x.Tag)
			} else {
				z.DecFallback(&x.Tag, false)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Order) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj9 int
	var yyb9 bool
	var yyhl9 bool = l >= 0
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt11 := z.Extension(x.Expr); yyxt11 != nil {
		z.DecExtension(&x.Expr, yyxt11)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Dir = (bool)(r.DecodeBool())
	yyj9++
	if yyhl9 {
		yyb9 = yyj9 > l
	} else {
		yyb9 = z.DecCheckBreak()
	}
	if yyb9 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Tag); yyxt14 != nil {
		z.DecExtension(&x.Tag, yyxt14)
	} else if !z.DecBinary() {
		z.DecTextUnmarshal(&x.Tag)
	} else {
		z.DecFallback(&x.Tag, false)
	}
	for {
		yyj9++
		if yyhl9 {
			yyb9 = yyj9 > l
		} else {
			yyb9 = z.DecCheckBreak()
		}
		if yyb9 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj9-1, "")
	}
}

func (x *Order) IsCodecEmpty() bool {
	return !(x.Expr != nil && bool(x.Dir) && x.Tag != pkg1_language.Tag{} && true)
}

func (x Orders) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encOrders((Orders)(x), e)
	} // end block: if x slice == nil
}

func (x *Orders) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decOrders((*Orders)(x), d)
}

func (x *Fetch) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Expr); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *Fetch) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Fetch{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Fetch) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Fetch) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Expr); yyxt8 != nil {
		z.DecExtension(&x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *Fetch) IsCodecEmpty() bool {
	return !(x.Expr != nil && true)
}

func (x Fetchs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encFetchs((Fetchs)(x), e)
	} // end block: if x slice == nil
}

func (x *Fetchs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decFetchs((*Fetchs)(x), d)
}

func (x *SubExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Expr); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				z.EncFallback(x.Expr)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SubExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = SubExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *SubExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				z.DecFallback(&x.Expr, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SubExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Expr); yyxt8 != nil {
		z.DecExtension(&x.Expr, yyxt8)
	} else {
		z.DecFallback(&x.Expr, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *SubExpression) IsCodecEmpty() bool {
	return !(x.Expr != nil && true)
}

func (x *MultExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Expr == nil {
				r.EncodeNil()
			} else {
				h.encSliceExpr(([]Expr)(x.Expr), e)
			} // end block: if x.Expr slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if x.Expr == nil {
				r.EncodeNil()
			} else {
				h.encSliceExpr(([]Expr)(x.Expr), e)
			} // end block: if x.Expr slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *MultExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = MultExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *MultExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			h.decSliceExpr((*[]Expr)(&x.Expr), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *MultExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSliceExpr((*[]Expr)(&x.Expr), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *MultExpression) IsCodecEmpty() bool {
	return !(len(x.Expr) != 0 && true)
}

func (x *FuncExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.Name))
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Args); yyxt7 != nil {
				z.EncExtension(x.Args, yyxt7)
			} else {
				x.Args.CodecEncodeSelf(e)
			}
			z.EncWriteArrayElem()
			r.EncodeBool(bool(x.Aggr))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.Name))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Args\"")
			} else {
				r.EncodeString(`Args`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(x.Args); yyxt10 != nil {
				z.EncExtension(x.Args, yyxt10)
			} else {
				x.Args.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Aggr\"")
			} else {
				r.EncodeString(`Aggr`)
			}
			z.EncWriteMapElemValue()
			r.EncodeBool(bool(x.Aggr))
			z.EncWriteMapEnd()
		}
	}
}

func (x *FuncExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = FuncExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *FuncExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Name":
			x.Name = (string)(string(r.DecodeStringAsBytes()))
		case "Args":
			if yyxt6 := z.Extension(x.Args); yyxt6 != nil {
				z.DecExtension(&x.Args, yyxt6)
			} else {
				x.Args.CodecDecodeSelf(d)
			}
		case "Aggr":
			x.Aggr = (bool)(r.DecodeBool())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *FuncExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Name = (string)(string(r.DecodeStringAsBytes()))
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt11 := z.Extension(x.Args); yyxt11 != nil {
		z.DecExtension(&x.Args, yyxt11)
	} else {
		x.Args.CodecDecodeSelf(d)
	}
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.Aggr = (bool)(r.DecodeBool())
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *FuncExpression) IsCodecEmpty() bool {
	return !(x.Name != "" && len(x.Args) != 0 && bool(x.Aggr) && true)
}

func (x *ItemExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.LHS); yyxt6 != nil {
				z.EncExtension(x.LHS, yyxt6)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Op); yyxt7 != nil {
				z.EncExtension(x.Op, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.RHS); yyxt8 != nil {
				z.EncExtension(x.RHS, yyxt8)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"LHS\"")
			} else {
				r.EncodeString(`LHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(x.LHS); yyxt9 != nil {
				z.EncExtension(x.LHS, yyxt9)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Op\"")
			} else {
				r.EncodeString(`Op`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(x.Op); yyxt10 != nil {
				z.EncExtension(x.Op, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RHS\"")
			} else {
				r.EncodeString(`RHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.RHS); yyxt11 != nil {
				z.EncExtension(x.RHS, yyxt11)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *ItemExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = ItemExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *ItemExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LHS":
			if yyxt5 := z.Extension(x.LHS); yyxt5 != nil {
				z.DecExtension(&x.LHS, yyxt5)
			} else {
				z.DecFallback(&x.LHS, true)
			}
		case "Op":
			if yyxt7 := z.Extension(x.Op); yyxt7 != nil {
				z.DecExtension(&x.Op, yyxt7)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Op)
			} else {
				x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "RHS":
			if yyxt9 := z.Extension(x.RHS); yyxt9 != nil {
				z.DecExtension(&x.RHS, yyxt9)
			} else {
				z.DecFallback(&x.RHS, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ItemExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.LHS); yyxt12 != nil {
		z.DecExtension(&x.LHS, yyxt12)
	} else {
		z.DecFallback(&x.LHS, true)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Op); yyxt14 != nil {
		z.DecExtension(&x.Op, yyxt14)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Op)
	} else {
		x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.RHS); yyxt16 != nil {
		z.DecExtension(&x.RHS, yyxt16)
	} else {
		z.DecFallback(&x.RHS, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *ItemExpression) IsCodecEmpty() bool {
	return !(x.LHS != nil && x.Op != 0 && x.RHS != nil && true)
}

func (x *BinaryExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.LHS); yyxt6 != nil {
				z.EncExtension(x.LHS, yyxt6)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Op); yyxt7 != nil {
				z.EncExtension(x.Op, yyxt7)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.RHS); yyxt8 != nil {
				z.EncExtension(x.RHS, yyxt8)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"LHS\"")
			} else {
				r.EncodeString(`LHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(x.LHS); yyxt9 != nil {
				z.EncExtension(x.LHS, yyxt9)
			} else {
				z.EncFallback(x.LHS)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Op\"")
			} else {
				r.EncodeString(`Op`)
			}
			z.EncWriteMapElemValue()
			if yyxt10 := z.Extension(x.Op); yyxt10 != nil {
				z.EncExtension(x.Op, yyxt10)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Op)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Op)
			} else {
				r.EncodeInt(int64(x.Op))
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"RHS\"")
			} else {
				r.EncodeString(`RHS`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.RHS); yyxt11 != nil {
				z.EncExtension(x.RHS, yyxt11)
			} else {
				z.EncFallback(x.RHS)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *BinaryExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = BinaryExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *BinaryExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LHS":
			if yyxt5 := z.Extension(x.LHS); yyxt5 != nil {
				z.DecExtension(&x.LHS, yyxt5)
			} else {
				z.DecFallback(&x.LHS, true)
			}
		case "Op":
			if yyxt7 := z.Extension(x.Op); yyxt7 != nil {
				z.DecExtension(&x.Op, yyxt7)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Op)
			} else {
				x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		case "RHS":
			if yyxt9 := z.Extension(x.RHS); yyxt9 != nil {
				z.DecExtension(&x.RHS, yyxt9)
			} else {
				z.DecFallback(&x.RHS, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *BinaryExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.LHS); yyxt12 != nil {
		z.DecExtension(&x.LHS, yyxt12)
	} else {
		z.DecFallback(&x.LHS, true)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Op); yyxt14 != nil {
		z.DecExtension(&x.Op, yyxt14)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Op)
	} else {
		x.Op = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.RHS); yyxt16 != nil {
		z.DecExtension(&x.RHS, yyxt16)
	} else {
		z.DecFallback(&x.RHS, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *BinaryExpression) IsCodecEmpty() bool {
	return !(x.LHS != nil && x.Op != 0 && x.RHS != nil && true)
}

func (x *PathExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Expr); yyxt4 != nil {
				z.EncExtension(x.Expr, yyxt4)
			} else {
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Expr\"")
			} else {
				r.EncodeString(`Expr`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.EncExtension(x.Expr, yyxt5)
			} else {
				x.Expr.CodecEncodeSelf(e)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *PathExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = PathExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *PathExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Expr":
			if yyxt5 := z.Extension(x.Expr); yyxt5 != nil {
				z.DecExtension(&x.Expr, yyxt5)
			} else {
				x.Expr.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PathExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Expr); yyxt8 != nil {
		z.DecExtension(&x.Expr, yyxt8)
	} else {
		x.Expr.CodecDecodeSelf(d)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *PathExpression) IsCodecEmpty() bool {
	return !(len(x.Expr) != 0 && true)
}

func (x *PartExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Part); yyxt4 != nil {
				z.EncExtension(x.Part, yyxt4)
			} else {
				z.EncFallback(x.Part)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Part\"")
			} else {
				r.EncodeString(`Part`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Part); yyxt5 != nil {
				z.EncExtension(x.Part, yyxt5)
			} else {
				z.EncFallback(x.Part)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *PartExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = PartExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *PartExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Part":
			if yyxt5 := z.Extension(x.Part); yyxt5 != nil {
				z.DecExtension(&x.Part, yyxt5)
			} else {
				z.DecFallback(&x.Part, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PartExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Part); yyxt8 != nil {
		z.DecExtension(&x.Part, yyxt8)
	} else {
		z.DecFallback(&x.Part, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *PartExpression) IsCodecEmpty() bool {
	return !(x.Part != nil && true)
}

func (x *JoinExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Join); yyxt4 != nil {
				z.EncExtension(x.Join, yyxt4)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Join)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Join)
			} else {
				r.EncodeInt(int64(x.Join))
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Join\"")
			} else {
				r.EncodeString(`Join`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Join); yyxt5 != nil {
				z.EncExtension(x.Join, yyxt5)
			} else if z.EncBinary() {
				z.EncBinaryMarshal(x.Join)
			} else if !z.EncBinary() {
				z.EncTextMarshal(x.Join)
			} else {
				r.EncodeInt(int64(x.Join))
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *JoinExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = JoinExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *JoinExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Join":
			if yyxt5 := z.Extension(x.Join); yyxt5 != nil {
				z.DecExtension(&x.Join, yyxt5)
			} else if z.DecBinary() {
				z.DecBinaryUnmarshal(&x.Join)
			} else {
				x.Join = (Token)(z.C.IntV(r.DecodeInt64(), 16))
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *JoinExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Join); yyxt8 != nil {
		z.DecExtension(&x.Join, yyxt8)
	} else if z.DecBinary() {
		z.DecBinaryUnmarshal(&x.Join)
	} else {
		x.Join = (Token)(z.C.IntV(r.DecodeInt64(), 16))
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *JoinExpression) IsCodecEmpty() bool {
	return !(x.Join != 0 && true)
}

func (x *SubpExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		var yyn4 bool = x.Name == nil
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(3)
			z.EncWriteArrayElem()
			if yyxt6 := z.Extension(x.What); yyxt6 != nil {
				z.EncExtension(x.What, yyxt6)
			} else {
				x.What.CodecEncodeSelf(e)
			}
			if yyn4 {
				z.EncWriteArrayElem()
				r.EncodeNil()
			} else {
				z.EncWriteArrayElem()
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.EncExtension(x.Name, yyxt7)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Cond); yyxt8 != nil {
				z.EncExtension(x.Cond, yyxt8)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(3)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"What\"")
			} else {
				r.EncodeString(`What`)
			}
			z.EncWriteMapElemValue()
			if yyxt9 := z.Extension(x.What); yyxt9 != nil {
				z.EncExtension(x.What, yyxt9)
			} else {
				x.What.CodecEncodeSelf(e)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Name\"")
			} else {
				r.EncodeString(`Name`)
			}
			z.EncWriteMapElemValue()
			if yyn4 {
				r.EncodeNil()
			} else {
				if yyxt10 := z.Extension(x.Name); yyxt10 != nil {
					z.EncExtension(x.Name, yyxt10)
					x.Name.CodecEncodeSelf(e)
				}
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Cond\"")
			} else {
				r.EncodeString(`Cond`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.Cond); yyxt11 != nil {
				z.EncExtension(x.Cond, yyxt11)
			} else {
				z.EncFallback(x.Cond)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *SubpExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = SubpExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *SubpExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "What":
			if yyxt5 := z.Extension(x.What); yyxt5 != nil {
				z.DecExtension(&x.What, yyxt5)
			} else {
				x.What.CodecDecodeSelf(d)
			}
		case "Name":
			if r.TryNil() {
				if x.Name != nil { // remove the if-true
					x.Name = nil
				}
			} else {
				if x.Name == nil {
					x.Name = new(Ident)
				}
				if yyxt7 := z.Extension(x.Name); yyxt7 != nil {
					z.DecExtension(x.Name, yyxt7)
				} else {
					x.Name.CodecDecodeSelf(d)
				}
			}
		case "Cond":
			if yyxt9 := z.Extension(x.Cond); yyxt9 != nil {
				z.DecExtension(&x.Cond, yyxt9)
			} else {
				z.DecFallback(&x.Cond, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *SubpExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj10 int
	var yyb10 bool
	var yyhl10 bool = l >= 0
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt12 := z.Extension(x.What); yyxt12 != nil {
		z.DecExtension(&x.What, yyxt12)
	} else {
		x.What.CodecDecodeSelf(d)
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.Name != nil { // remove the if-true
			x.Name = nil
		}
	} else {
		if x.Name == nil {
			x.Name = new(Ident)
		}
		if yyxt14 := z.Extension(x.Name); yyxt14 != nil {
			z.DecExtension(x.Name, yyxt14)
		} else {
			x.Name.CodecDecodeSelf(d)
		}
	}
	yyj10++
	if yyhl10 {
		yyb10 = yyj10 > l
	} else {
		yyb10 = z.DecCheckBreak()
	}
	if yyb10 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Cond); yyxt16 != nil {
		z.DecExtension(&x.Cond, yyxt16)
	} else {
		z.DecFallback(&x.Cond, true)
	}
	for {
		yyj10++
		if yyhl10 {
			yyb10 = yyj10 > l
		} else {
			yyb10 = z.DecCheckBreak()
		}
		if yyb10 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj10-1, "")
	}
}

func (x *SubpExpression) IsCodecEmpty() bool {
	return !(len(x.What) != 0 && x.Cond != nil && true)
}

func (x *PermExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			if yyxt7 := z.Extension(x.Select); yyxt7 != nil {
				z.EncExtension(x.Select, yyxt7)
			} else {
				z.EncFallback(x.Select)
			}
			z.EncWriteArrayElem()
			if yyxt8 := z.Extension(x.Create); yyxt8 != nil {
				z.EncExtension(x.Create, yyxt8)
			} else {
				z.EncFallback(x.Create)
			}
			z.EncWriteArrayElem()
			if yyxt9 := z.Extension(x.Update); yyxt9 != nil {
				z.EncExtension(x.Update, yyxt9)
			} else {
				z.EncFallback(x.Update)
			}
			z.EncWriteArrayElem()
			if yyxt10 := z.Extension(x.Delete); yyxt10 != nil {
				z.EncExtension(x.Delete, yyxt10)
			} else {
				z.EncFallback(x.Delete)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Select\"")
			} else {
				r.EncodeString(`Select`)
			}
			z.EncWriteMapElemValue()
			if yyxt11 := z.Extension(x.Select); yyxt11 != nil {
				z.EncExtension(x.Select, yyxt11)
			} else {
				z.EncFallback(x.Select)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Create\"")
			} else {
				r.EncodeString(`Create`)
			}
			z.EncWriteMapElemValue()
			if yyxt12 := z.Extension(x.Create); yyxt12 != nil {
				z.EncExtension(x.Create, yyxt12)
			} else {
				z.EncFallback(x.Create)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Update\"")
			} else {
				r.EncodeString(`Update`)
			}
			z.EncWriteMapElemValue()
			if yyxt13 := z.Extension(x.Update); yyxt13 != nil {
				z.EncExtension(x.Update, yyxt13)
			} else {
				z.EncFallback(x.Update)
			}
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Delete\"")
			} else {
				r.EncodeString(`Delete`)
			}
			z.EncWriteMapElemValue()
			if yyxt14 := z.Extension(x.Delete); yyxt14 != nil {
				z.EncExtension(x.Delete, yyxt14)
			} else {
				z.EncFallback(x.Delete)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *PermExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = PermExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *PermExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Select":
			if yyxt5 := z.Extension(x.Select); yyxt5 != nil {
				z.DecExtension(&x.Select, yyxt5)
			} else {
				z.DecFallback(&x.Select, true)
			}
		case "Create":
			if yyxt7 := z.Extension(x.Create); yyxt7 != nil {
				z.DecExtension(&x.Create, yyxt7)
			} else {
				z.DecFallback(&x.Create, true)
			}
		case "Update":
			if yyxt9 := z.Extension(x.Update); yyxt9 != nil {
				z.DecExtension(&x.Update, yyxt9)
			} else {
				z.DecFallback(&x.Update, true)
			}
		case "Delete":
			if yyxt11 := z.Extension(x.Delete); yyxt11 != nil {
				z.DecExtension(&x.Delete, yyxt11)
			} else {
				z.DecFallback(&x.Delete, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *PermExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj12 int
	var yyb12 bool
	var yyhl12 bool = l >= 0
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt14 := z.Extension(x.Select); yyxt14 != nil {
		z.DecExtension(&x.Select, yyxt14)
	} else {
		z.DecFallback(&x.Select, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt16 := z.Extension(x.Create); yyxt16 != nil {
		z.DecExtension(&x.Create, yyxt16)
	} else {
		z.DecFallback(&x.Create, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt18 := z.Extension(x.Update); yyxt18 != nil {
		z.DecExtension(&x.Update, yyxt18)
	} else {
		z.DecFallback(&x.Update, true)
	}
	yyj12++
	if yyhl12 {
		yyb12 = yyj12 > l
	} else {
		yyb12 = z.DecCheckBreak()
	}
	if yyb12 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt20 := z.Extension(x.Delete); yyxt20 != nil {
		z.DecExtension(&x.Delete, yyxt20)
	} else {
		z.DecFallback(&x.Delete, true)
	}
	for {
		yyj12++
		if yyhl12 {
			yyb12 = yyj12 > l
		} else {
			yyb12 = z.DecCheckBreak()
		}
		if yyb12 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj12-1, "")
	}
}

func (x *PermExpression) IsCodecEmpty() bool {
	return !(x.Select != nil && x.Create != nil && x.Update != nil && x.Delete != nil && true)
}

func (x *DataExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoItemExpression(([]*ItemExpression)(x.Data), e)
			} // end block: if x.Data slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if x.Data == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoItemExpression(([]*ItemExpression)(x.Data), e)
			} // end block: if x.Data slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *DataExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DataExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DataExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			h.decSlicePtrtoItemExpression((*[]*ItemExpression)(&x.Data), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DataExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoItemExpression((*[]*ItemExpression)(&x.Data), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DataExpression) IsCodecEmpty() bool {
	return !(len(x.Data) != 0 && true)
}

func (x *DiffExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Data); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *DiffExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = DiffExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *DiffExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.DecExtension(&x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *DiffExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Data); yyxt8 != nil {
		z.DecExtension(&x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *DiffExpression) IsCodecEmpty() bool {
	return !(x.Data != nil && true)
}

func (x *MergeExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Data); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *MergeExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = MergeExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *MergeExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.DecExtension(&x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *MergeExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Data); yyxt8 != nil {
		z.DecExtension(&x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *MergeExpression) IsCodecEmpty() bool {
	return !(x.Data != nil && true)
}

func (x *ContentExpression) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			if yyxt4 := z.Extension(x.Data); yyxt4 != nil {
				z.EncExtension(x.Data, yyxt4)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"Data\"")
			} else {
				r.EncodeString(`Data`)
			}
			z.EncWriteMapElemValue()
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.EncExtension(x.Data, yyxt5)
			} else {
				z.EncFallback(x.Data)
			}
			z.EncWriteMapEnd()
		}
	}
}

func (x *ContentExpression) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = ContentExpression{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *ContentExpression) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "Data":
			if yyxt5 := z.Extension(x.Data); yyxt5 != nil {
				z.DecExtension(&x.Data, yyxt5)
			} else {
				z.DecFallback(&x.Data, true)
			}
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *ContentExpression) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if yyxt8 := z.Extension(x.Data); yyxt8 != nil {
		z.DecExtension(&x.Data, yyxt8)
	} else {
		z.DecFallback(&x.Data, true)
	}
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *ContentExpression) IsCodecEmpty() bool {
	return !(x.Data != nil && true)
}

func (x Params) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encParams((Params)(x), e)
	} // end block: if x slice == nil
}

func (x *Params) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decParams((*Params)(x), d)
}

func (x *Param) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Param) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Param{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Param) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Param) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *Param) IsCodecEmpty() bool {
	return !(x.VA != "" && true)
}

func (x Idents) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encIdents((Idents)(x), e)
	} // end block: if x slice == nil
}

func (x *Idents) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decIdents((*Idents)(x), d)
}

func (x *Ident) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Ident) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Ident{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Ident) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Ident) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *Ident) IsCodecEmpty() bool {
	return !(x.VA != "" && true)
}

func (x Values) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encValues((Values)(x), e)
	} // end block: if x slice == nil
}

func (x *Values) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decValues((*Values)(x), d)
}

func (x *Value) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Value) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Value{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Value) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Value) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *Value) IsCodecEmpty() bool {
	return !(x.VA != "" && true)
}

func (x Regexs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encRegexs((Regexs)(x), e)
	} // end block: if x slice == nil
}

func (x *Regexs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decRegexs((*Regexs)(x), d)
}

func (x *Regex) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.VA))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"VA\"")
			} else {
				r.EncodeString(`VA`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.VA))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Regex) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Regex{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Regex) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "VA":
			x.VA = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Regex) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.VA = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *Regex) IsCodecEmpty() bool {
	return !(x.VA != "" && true)
}

func (x Tables) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encTables((Tables)(x), e)
	} // end block: if x slice == nil
}

func (x *Tables) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decTables((*Tables)(x), d)
}

func (x *Table) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(1)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(1)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Table) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Table{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Table) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Table) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj5 int
	var yyb5 bool
	var yyhl5 bool = l >= 0
	yyj5++
	if yyhl5 {
		yyb5 = yyj5 > l
	} else {
		yyb5 = z.DecCheckBreak()
	}
	if yyb5 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	for {
		yyj5++
		if yyhl5 {
			yyb5 = yyj5 > l
		} else {
			yyb5 = z.DecCheckBreak()
		}
		if yyb5 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj5-1, "")
	}
}

func (x *Table) IsCodecEmpty() bool {
	return !(x.TB != "" && true)
}

func (x Batchs) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encBatchs((Batchs)(x), e)
	} // end block: if x slice == nil
}

func (x *Batchs) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decBatchs((*Batchs)(x), d)
}

func (x *Batch) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(2)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayElem()
			if x.BA == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoThing(([]*Thing)(x.BA), e)
			} // end block: if x.BA slice == nil
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(2)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"BA\"")
			} else {
				r.EncodeString(`BA`)
			}
			z.EncWriteMapElemValue()
			if x.BA == nil {
				r.EncodeNil()
			} else {
				h.encSlicePtrtoThing(([]*Thing)(x.BA), e)
			} // end block: if x.BA slice == nil
			z.EncWriteMapEnd()
		}
	}
}

func (x *Batch) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Batch{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Batch) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "BA":
			h.decSlicePtrtoThing((*[]*Thing)(&x.BA), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Batch) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoThing((*[]*Thing)(&x.BA), d)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *Batch) IsCodecEmpty() bool {
	return !(x.TB != "" && len(x.BA) != 0 && true)
}

func (x Models) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encModels((Models)(x), e)
	} // end block: if x slice == nil
}

func (x *Models) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decModels((*Models)(x), d)
}

func (x *Model) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yy2arr2 := z.EncBasicHandle().StructToArray
		_ = yy2arr2
		const yyr2 bool = false // struct tag has 'toArray'
		if yyr2 || yy2arr2 {
			z.EncWriteArrayStart(4)
			z.EncWriteArrayElem()
			r.EncodeString(string(x.TB))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.MIN))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.INC))
			z.EncWriteArrayElem()
			r.EncodeFloat64(float64(x.MAX))
			z.EncWriteArrayEnd()
		} else {
			z.EncWriteMapStart(4)
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"TB\"")
			} else {
				r.EncodeString(`TB`)
			}
			z.EncWriteMapElemValue()
			r.EncodeString(string(x.TB))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MIN\"")
			} else {
				r.EncodeString(`MIN`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.MIN))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"INC\"")
			} else {
				r.EncodeString(`INC`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.INC))
			z.EncWriteMapElemKey()
			if z.IsJSONHandle() {
				z.WriteStr("\"MAX\"")
			} else {
				r.EncodeString(`MAX`)
			}
			z.EncWriteMapElemValue()
			r.EncodeFloat64(float64(x.MAX))
			z.EncWriteMapEnd()
		}
	}
}

func (x *Model) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Model{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Model) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "MIN":
			x.MIN = (float64)(r.DecodeFloat64())
		case "INC":
			x.INC = (float64)(r.DecodeFloat64())
		case "MAX":
			x.MAX = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Model) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj8 int
	var yyb8 bool
	var yyhl8 bool = l >= 0
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.MIN = (float64)(r.DecodeFloat64())
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.INC = (float64)(r.DecodeFloat64())
	yyj8++
	if yyhl8 {
		yyb8 = yyj8 > l
	} else {
		yyb8 = z.DecCheckBreak()
	}
	if yyb8 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.MAX = (float64)(r.DecodeFloat64())
	for {
		yyj8++
		if yyhl8 {
			yyb8 = yyj8 > l
		} else {
			yyb8 = z.DecCheckBreak()
		}
		if yyb8 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj8-1, "")
	}
}

func (x *Model) IsCodecEmpty() bool {
	return !(x.TB != "" && x.MIN != 0 && x.INC != 0 && x.MAX != 0 && true)
}

func (x Things) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encThings((Things)(x), e)
	} // end block: if x slice == nil
}

func (x *Things) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decThings((*Things)(x), d)
}

func (x *Thing) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() {
			z.EncTextMarshal(*x)
		} else {
			yy2arr2 := z.EncBasicHandle().StructToArray
			_ = yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(2)
				z.EncWriteArrayElem()
				r.EncodeString(string(x.TB))
				z.EncWriteArrayElem()
				z.EncFallback(x.ID)
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(2)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"TB\"")
				} else {
					r.EncodeString(`TB`)
				}
				z.EncWriteMapElemValue()
				r.EncodeString(string(x.TB))
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"ID\"")
				} else {
					r.EncodeString(`ID`)
				}
				z.EncWriteMapElemValue()
				z.EncFallback(x.ID)
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Thing) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Thing{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Thing) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "TB":
			x.TB = (string)(string(r.DecodeStringAsBytes()))
		case "ID":
			z.DecFallback(&x.ID, true)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Thing) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.TB = (string)(string(r.DecodeStringAsBytes()))
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	z.DecFallback(&x.ID, true)
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *Thing) IsCodecEmpty() bool {
	return !(x.TB != "" && x.ID != nil && true)
}

func (x Points) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encPoints((Points)(x), e)
	} // end block: if x slice == nil
}

func (x *Points) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decPoints((*Points)(x), d)
}

func (x *Point) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(*x)
		} else {
			yy2arr2 := z.EncBasicHandle().StructToArray
			_ = yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(2)
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.LA))
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.LO))
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(2)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"LA\"")
				} else {
					r.EncodeString(`LA`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.LA))
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"LO\"")
				} else {
					r.EncodeString(`LO`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.LO))
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Point) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Point{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Point) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "LA":
			x.LA = (float64)(r.DecodeFloat64())
		case "LO":
			x.LO = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Point) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.LA = (float64)(r.DecodeFloat64())
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.LO = (float64)(r.DecodeFloat64())
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *Point) IsCodecEmpty() bool {
	return !(x.LA != 0 && x.LO != 0 && true)
}

func (x Circles) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encCircles((Circles)(x), e)
	} // end block: if x slice == nil
}

func (x *Circles) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decCircles((*Circles)(x), d)
}

func (x *Circle) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(*x)
		} else {
			yy2arr2 := z.EncBasicHandle().StructToArray
			_ = yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			var yyn3 bool = x.CE == nil
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(2)
				if yyn3 {
					z.EncWriteArrayElem()
					r.EncodeNil()
				} else {
					z.EncWriteArrayElem()
					if yyxt5 := z.Extension(x.CE); yyxt5 != nil {
						z.EncExtension(x.CE, yyxt5)
					} else {
						x.CE.CodecEncodeSelf(e)
					}
				}
				z.EncWriteArrayElem()
				r.EncodeFloat64(float64(x.RA))
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(2)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"CE\"")
				} else {
					r.EncodeString(`CE`)
				}
				z.EncWriteMapElemValue()
				if yyn3 {
					r.EncodeNil()
				} else {
					if yyxt7 := z.Extension(x.CE); yyxt7 != nil {
						z.EncExtension(x.CE, yyxt7)
					} else {
						x.CE.CodecEncodeSelf(e)
					}
				}
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"RA\"")
				} else {
					r.EncodeString(`RA`)
				}
				z.EncWriteMapElemValue()
				r.EncodeFloat64(float64(x.RA))
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Circle) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Circle{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Circle) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "CE":
			if r.TryNil() {
				if x.CE != nil { // remove the if-true
					x.CE = nil
				}
			} else {
				if x.CE == nil {
					x.CE = new(Point)
				}
				if yyxt5 := z.Extension(x.CE); yyxt5 != nil {
					z.DecExtension(x.CE, yyxt5)
				} else {
					x.CE.CodecDecodeSelf(d)
				}
			}
		case "RA":
			x.RA = (float64)(r.DecodeFloat64())
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Circle) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj7 int
	var yyb7 bool
	var yyhl7 bool = l >= 0
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	if r.TryNil() {
		if x.CE != nil { // remove the if-true
			x.CE = nil
		}
	} else {
		if x.CE == nil {
			x.CE = new(Point)
		}
		if yyxt9 := z.Extension(x.CE); yyxt9 != nil {
			z.DecExtension(x.CE, yyxt9)
		} else {
			x.CE.CodecDecodeSelf(d)
		}
	}
	yyj7++
	if yyhl7 {
		yyb7 = yyj7 > l
	} else {
		yyb7 = z.DecCheckBreak()
	}
	if yyb7 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	x.RA = (float64)(r.DecodeFloat64())
	for {
		yyj7++
		if yyhl7 {
			yyb7 = yyj7 > l
		} else {
			yyb7 = z.DecCheckBreak()
		}
		if yyb7 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj7-1, "")
	}
}

func (x *Circle) IsCodecEmpty() bool {
	return !(x.RA != 0 && true)
}

func (x Polygons) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		h.encPolygons((Polygons)(x), e)
	} // end block: if x slice == nil
}

func (x *Polygons) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	h.decPolygons((*Polygons)(x), d)
}

func (x *Polygon) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		if !z.EncBinary() && z.IsJSONHandle() {
			z.EncJSONMarshal(*x)
		} else {
			yy2arr2 := z.EncBasicHandle().StructToArray
			_ = yy2arr2
			const yyr2 bool = false // struct tag has 'toArray'
			if yyr2 || yy2arr2 {
				z.EncWriteArrayStart(1)
				z.EncWriteArrayElem()
				if x.PS == nil {
					r.EncodeNil()
				} else {
					h.encSlicePtrtoPoint(([]*Point)(x.PS), e)
				} // end block: if x.PS slice == nil
				z.EncWriteArrayEnd()
			} else {
				z.EncWriteMapStart(1)
				z.EncWriteMapElemKey()
				if z.IsJSONHandle() {
					z.WriteStr("\"PS\"")
				} else {
					r.EncodeString(`PS`)
				}
				z.EncWriteMapElemValue()
				if x.PS == nil {
					r.EncodeNil()
				} else {
					h.encSlicePtrtoPoint(([]*Point)(x.PS), e)
				} // end block: if x.PS slice == nil
				z.EncWriteMapEnd()
			}
		}
	}
}

func (x *Polygon) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	yyct2 := r.ContainerType()
	if yyct2 == codecSelferValueTypeNil8312 {
		*(x) = Polygon{}
	} else if yyct2 == codecSelferValueTypeMap8312 {
		yyl2 := z.DecReadMapStart()
		if yyl2 == 0 {
		} else {
			x.codecDecodeSelfFromMap(yyl2, d)
		}
		z.DecReadMapEnd()
	} else if yyct2 == codecSelferValueTypeArray8312 {
		yyl2 := z.DecReadArrayStart()
		if yyl2 != 0 {
			x.codecDecodeSelfFromArray(yyl2, d)
		}
		z.DecReadArrayEnd()
	} else {
		panic(errCodecSelferOnlyMapOrArrayEncodeToStruct8312)
	}
}

func (x *Polygon) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyhl3 bool = l >= 0
	for yyj3 := 0; ; yyj3++ {
		if yyhl3 {
			if yyj3 >= l {
				break
			}
		} else {
			if z.DecCheckBreak() {
				break
			}
		}
		z.DecReadMapElemKey()
		yys3 := z.StringView(r.DecodeStringAsBytes())
		z.DecReadMapElemValue()
		switch yys3 {
		case "PS":
			h.decSlicePtrtoPoint((*[]*Point)(&x.PS), d)
		default:
			z.DecStructFieldNotFound(-1, yys3)
		} // end switch yys3
	} // end for yyj3
}

func (x *Polygon) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r
	var yyj6 int
	var yyb6 bool
	var yyhl6 bool = l >= 0
	yyj6++
	if yyhl6 {
		yyb6 = yyj6 > l
	} else {
		yyb6 = z.DecCheckBreak()
	}
	if yyb6 {
		z.DecReadArrayEnd()
		return
	}
	z.DecReadArrayElem()
	h.decSlicePtrtoPoint((*[]*Point)(&x.PS), d)
	for {
		yyj6++
		if yyhl6 {
			yyb6 = yyj6 > l
		} else {
			yyb6 = z.DecCheckBreak()
		}
		if yyb6 {
			break
		}
		z.DecReadArrayElem()
		z.DecStructFieldNotFound(yyj6-1, "")
	}
}

func (x *Polygon) IsCodecEmpty() bool {
	return !(len(x.PS) != 0 && true)
}

func (x codecSelfer8312) encStatements(v Statements, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decStatements(v *Statements, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Statement{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Statement, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Statement, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
					z.DecExtension(&yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Statement, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encExprs(v Exprs, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decExprs(v *Exprs, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Expr{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Expr, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Expr, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
					z.DecExtension(&yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Expr, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encFields(v Fields, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decFields(v *Fields, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Field{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Field, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Field, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Field)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Field, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encGroups(v Groups, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decGroups(v *Groups, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Group{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Group, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Group, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Group)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Group, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encOrders(v Orders, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decOrders(v *Orders, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Order{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Order, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Order, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Order)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Order, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encFetchs(v Fetchs, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decFetchs(v *Fetchs, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Fetch{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Fetch, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Fetch, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Fetch)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Fetch, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encSliceExpr(v []Expr, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				z.EncFallback(yyv1)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decSliceExpr(v *[]Expr, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []Expr{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]Expr, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 16)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]Expr, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
					z.DecExtension(&yyv1[yyj1], yyxt3)
				} else {
					z.DecFallback(&yyv1[yyj1], true)
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]Expr, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encSlicePtrtoItemExpression(v []*ItemExpression, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decSlicePtrtoItemExpression(v *[]*ItemExpression, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*ItemExpression{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*ItemExpression, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*ItemExpression, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(ItemExpression)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*ItemExpression, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encParams(v Params, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decParams(v *Params, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Param{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Param, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Param, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Param)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Param, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encIdents(v Idents, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decIdents(v *Idents, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Ident{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Ident, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Ident, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Ident)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Ident, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encValues(v Values, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decValues(v *Values, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Value{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Value, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Value, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Value)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Value, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encRegexs(v Regexs, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decRegexs(v *Regexs, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Regex{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Regex, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Regex, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Regex)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Regex, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encTables(v Tables, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decTables(v *Tables, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Table{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Table, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Table, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Table)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Table, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encBatchs(v Batchs, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decBatchs(v *Batchs, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Batch{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Batch, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Batch, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Batch)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Batch, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encSlicePtrtoThing(v []*Thing, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decSlicePtrtoThing(v *[]*Thing, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Thing{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Thing, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Thing, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Thing)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Thing, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encModels(v Models, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decModels(v *Models, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Model{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Model, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Model, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Model)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Model, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encThings(v Things, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decThings(v *Things, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Thing{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Thing, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Thing, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Thing)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Thing, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encPoints(v Points, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decPoints(v *Points, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Point{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Point, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Point, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Point)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Point, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encCircles(v Circles, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decCircles(v *Circles, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Circle{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Circle, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Circle, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Circle)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Circle, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encPolygons(v Polygons, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decPolygons(v *Polygons, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Polygon{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Polygon, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Polygon, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Polygon)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Polygon, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}

func (x codecSelfer8312) encSlicePtrtoPoint(v []*Point, e *codec1978.Encoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Encoder(e)
	_, _, _ = h, z, r
	if v == nil {
		r.EncodeNil()
		return
	}
	z.EncWriteArrayStart(len(v))
	for _, yyv1 := range v {
		z.EncWriteArrayElem()
		if yyv1 == nil {
			r.EncodeNil()
		} else {
			if yyxt2 := z.Extension(yyv1); yyxt2 != nil {
				z.EncExtension(yyv1, yyxt2)
			} else {
				yyv1.CodecEncodeSelf(e)
			}
		}
	}
	z.EncWriteArrayEnd()
}

func (x codecSelfer8312) decSlicePtrtoPoint(v *[]*Point, d *codec1978.Decoder) {
	var h codecSelfer8312
	z, r := codec1978.GenHelper().Decoder(d)
	_, _, _ = h, z, r

	yyv1 := *v
	yyh1, yyl1 := z.DecSliceHelperStart()
	var yyc1 bool
	_ = yyc1
	if yyh1.IsNil {
		if yyv1 != nil {
			yyv1 = nil
			yyc1 = true
		}
	} else if yyl1 == 0 {
		if yyv1 == nil {
			yyv1 = []*Point{}
			yyc1 = true
		} else if len(yyv1) != 0 {
			yyv1 = yyv1[:0]
			yyc1 = true
		}
	} else {
		yyhl1 := yyl1 > 0
		var yyrl1 int
		_ = yyrl1
		if yyhl1 {
			if yyl1 > cap(yyv1) {
				yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				if yyrl1 <= cap(yyv1) {
					yyv1 = yyv1[:yyrl1]
				} else {
					yyv1 = make([]*Point, yyrl1)
				}
				yyc1 = true
			} else if yyl1 != len(yyv1) {
				yyv1 = yyv1[:yyl1]
				yyc1 = true
			}
		}
		var yyj1 int
		for yyj1 = 0; (yyhl1 && yyj1 < yyl1) || !(yyhl1 || z.DecCheckBreak()); yyj1++ { // bounds-check-elimination
			if yyj1 == 0 && yyv1 == nil {
				if yyhl1 {
					yyrl1 = z.DecInferLen(yyl1, z.DecBasicHandle().MaxInitLen, 8)
				} else {
					yyrl1 = 8
				}
				yyv1 = make([]*Point, yyrl1)
				yyc1 = true
			}
			yyh1.ElemContainerState(yyj1)
			var yydb1 bool
			if yyj1 >= len(yyv1) {
				yyv1 = append(yyv1, nil)
				yyc1 = true
			}
			if yydb1 {
				z.DecSwallow()
			} else {
				if r.TryNil() {
					yyv1[yyj1] = nil
				} else {
					if yyv1[yyj1] == nil {
						yyv1[yyj1] = new(Point)
					}
					if yyxt3 := z.Extension(yyv1[yyj1]); yyxt3 != nil {
						z.DecExtension(yyv1[yyj1], yyxt3)
					} else {
						yyv1[yyj1].CodecDecodeSelf(d)
					}
				}
			}
		}
		if yyj1 < len(yyv1) {
			yyv1 = yyv1[:yyj1]
			yyc1 = true
		} else if yyj1 == 0 && yyv1 == nil {
			yyv1 = make([]*Point, 0)
			yyc1 = true
		}
	}
	yyh1.End()
	if yyc1 {
		*v = yyv1
	}
}
